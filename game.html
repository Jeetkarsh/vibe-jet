<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibe Jet</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', monospace;
        }
        canvas { display: block; }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            background: linear-gradient(135deg, rgba(0,20,40,0.85), rgba(0,40,80,0.85));
            padding: 20px 25px;
            border-radius: 12px;
            border: 2px solid rgba(0,255,255,0.4);
            box-shadow: 0 0 30px rgba(0,255,255,0.3), inset 0 0 20px rgba(0,100,200,0.2);
            backdrop-filter: blur(10px);
            font-size: 16px;
            line-height: 1.8;
            letter-spacing: 1px;
        }

        #info span {
            color: #ffaa00;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255,170,0,0.8);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 2px solid rgba(0,255,255,0.6);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
        }

        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 60px;
            background: rgba(0,255,255,0.6);
        }

        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 2px;
            background: rgba(0,255,255,0.6);
        }

        #speedbar {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 300px;
            background: rgba(0,20,40,0.7);
            border: 2px solid rgba(0,255,255,0.4);
            border-radius: 10px;
            overflow: hidden;
        }

        #speedbar-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #00ffff, #ffaa00, #ff0000);
            transition: height 0.1s ease;
            box-shadow: 0 0 20px rgba(0,255,255,0.8);
        }

        #boost-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4400;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 24px;
            text-shadow: 0 0 20px rgba(255,68,0,1);
            display: none;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            50% { opacity: 0.7; transform: translateX(-50%) scale(1.1); }
        }
    </style>
    <link rel="shortcut icon" href="#">
</head>
<body>
    <div id="loading-indicator" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; font-family: 'Orbitron', monospace; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 5px; display: none;">
        Loading Model...
    </div>
    <div id="info">
        SPEED: <span id="speed">0</span> km/h<br>
        ALTITUDE: <span id="altitude">0</span> m<br>
        PLAYERS: <span id="players-count">1</span>
    </div>
    <div id="race-info" style="position: absolute; top: 20px; right: 20px; color: #00ffff; font-family: 'Orbitron', monospace; font-weight: 700; background: linear-gradient(135deg, rgba(0,20,40,0.85), rgba(0,40,80,0.85)); padding: 20px 25px; border-radius: 12px; border: 2px solid rgba(0,255,255,0.4); box-shadow: 0 0 30px rgba(0,255,255,0.3); backdrop-filter: blur(10px); font-size: 16px; line-height: 1.8; display: none;">
        TIME: <span id="race-time" style="color: #ffaa00; font-weight: 900; text-shadow: 0 0 10px rgba(255,170,0,0.8);">0.00</span>s<br>
        CHECKPOINT: <span id="checkpoint-progress" style="color: #00ff00; font-weight: 900;">0/10</span><br>
        <span id="best-time-display" style="font-size: 14px; color: #888;">BEST: --</span>
    </div>
    <div id="race-controls" style="position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); text-align: center;">
        <button id="start-race-btn" style="background: linear-gradient(135deg, #00ffff, #0099cc); color: #000; font-family: 'Orbitron', monospace; font-weight: 900; font-size: 18px; padding: 15px 40px; border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 0 20px rgba(0,255,255,0.5); transition: all 0.3s;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">START RACE</button>
    </div>
    <div id="crosshair"></div>
    <div id="speedbar">
        <div id="speedbar-fill" style="height: 0%;"></div>
    </div>
    <div id="boost-indicator">⚡ AFTERBURNER ⚡</div>
    <div id="checkpoint-notification" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ff00; font-family: 'Orbitron', monospace; font-weight: 900; font-size: 48px; text-shadow: 0 0 30px rgba(0,255,0,1); display: none; pointer-events: none; animation: pulse 0.5s;">
        CHECKPOINT!
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Optional for debugging

        // --- Configuration ---
        // Dynamic WebSocket URL - works locally and when deployed
        // Port can be overridden via ?wsport=XXXX query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const wsPort = urlParams.get('wsport') || '8080';
        const WEBSOCKET_URL = `ws://${window.location.hostname}:${wsPort}`;
        const PLAYER_SPEED = 200.0; // Base speed units/sec
        const AFTERBURNER_MULTIPLIER = 3.0;
        const ROLL_SPEED = Math.PI * 1.0; // Radians per second
        const PITCH_SPEED = Math.PI * 0.8; // Radians per second
        const YAW_SPEED = Math.PI * 0.5; // Radians per second
        const DAMPING = 0.95; // Velocity damping factor
        const CAMERA_BASE_FOV = 75;
        const CAMERA_MAX_FOV_BOOST = 25; // Additional FOV at max speed boost
        const UPDATE_INTERVAL_MS = 100; // Send updates every 100ms (10 Hz)
        const GROUND_SIZE = 8000;
        const GROUND_SEGMENTS = 100; // Segments for ground geometry/hills
        const BUILDING_COUNT = 200;
        const MAX_BUILDING_HEIGHT = 400;
        const MIN_BUILDING_HEIGHT = 50;
        const STAR_COUNT = 5000;
        const DAY_NIGHT_CYCLE_MINUTES = 10; // Duration of a full day/night cycle
        const ASSETS_DIR = 'assets/';
        // const MODEL_URL = 'https://unpkg.com/three@0.162.0/examples/models/gltf/Flamingo.glb'; // <-- REPLACE WITH YOUR AIRCRAFT MODEL URL (.glb/.gltf)
        const MODEL_URL = `${ASSETS_DIR}/shenyang_j-11.glb`; // <-- Use local filename
        const MODEL_SCALE = 0.8; // <-- ADJUST THIS scale to fit your model size
        const OTHER_PLAYER_COLOR = 0x00aaff; // A blue tint for other players
        // --- Terrain & Tree Constants ---
        const TERRAIN_AMPLITUDE = 50; // Max height of hills (Adjusted from 150)
        const TERRAIN_FREQUENCY = (8 * Math.PI * 2) / GROUND_SIZE; // How wavy. Higher value = more, smaller hills. Try a value relative to the size, aiming for ~5-10 waves across.
        const TREE_COUNT = 7000; // Number of trees (adjust based on performance)
        const TRUNK_HEIGHT = 10;
        const TRUNK_RADIUS = 2.0;
        const FOLIAGE_HEIGHT = 20;
        const FOLIAGE_RADIUS = 8;
        // --- Cloud Constants ---
        const CLOUD_COUNT = 200; // Number of cloud particles
        const CLOUD_SIZE = 1000; // Base size of each cloud particle
        const CLOUD_ALTITUDE_MIN = 600; // Minimum height for clouds
        const CLOUD_ALTITUDE_MAX = 1200; // Maximum height for clouds
        const CLOUD_AREA_XZ = GROUND_SIZE * 1.5; // How far clouds spread horizontally
        const CLOUD_DRIFT_SPEED = 5.0; // How fast clouds move horizontally
        const CLOUD_TEXTURE_URL = `${ASSETS_DIR}/cloud10.png`; // Example texture
        // --- Road Constants ---
        const ROAD_COUNT = 5; // Number of road segments
        const ROAD_WIDTH = 30; // Width of the roads
        const ROAD_MIN_LENGTH = 1000;
        const ROAD_MAX_LENGTH = 2000;
        const ROAD_SEGMENT_LENGTH = 10; // How finely to subdivide the road mesh along its length
        const ROAD_THICKNESS_OFFSET = 0.2; // Place roads slightly above terrain
        const ROAD_TEXTURE_URL = `${ASSETS_DIR}/road.jpg`; // Example texture

        // --- Global Variables ---
        let scene, camera, renderer, clock, skyLight, sunLight;
        let composer, bloomPass, ssaoPass;  // Post-processing
        let jetTrailParticles = [];          // Particle system for jet trails
        let playerAircraft = null; // Initialize as null
        let playerVelocity, playerAngularVelocity;
        let controls = { forward: 0, backward: 0, left: 0, right: 0, up: 0, down: 0, boost: 0 };
        let ws;
        let playerId = null;
        let otherPlayers = new Map(); // Map<playerId, { mesh: THREE.Mesh, lastUpdate: number }>
        let buildingBoundingBoxes = [];
        let lastUpdateTime = 0;
        let isColliding = false;
        let sunAngle = Math.PI / 4; // Start in morning/afternoon
        let loadedModelTemplate = null; // To store the loaded model for cloning
        let loadingManager = null;      // Optional for loading progress
        let loadingIndicator = null;    // Simple DOM element for loading message
        let clouds = null;              // Hold the Points object for animation
        let roadTexture = null;         // To store the loaded road texture

        // --- Performance Optimization Variables ---
        let playerBoundingBox = new THREE.Box3(); // Reusable bounding box for collision detection
        let playerCollisionRadius = 15.0; // Sphere collision radius for faster checks
        let frameCount = 0; // For periodic quaternion normalization

        // --- Visual Effects Variables ---
        let cameraShake = new THREE.Vector3(); // Camera shake offset
        let shakeIntensity = 0; // Current shake intensity
        let speedLinesPass = null; // Speed lines shader pass

        // --- Gameplay Variables ---
        let checkpoints = []; // Array of checkpoint rings
        let currentCheckpoint = 0; // Index of next checkpoint to pass
        let checkpointsPassed = 0; // Total checkpoints passed
        let raceStartTime = 0; // Race timer start
        let raceTime = 0; // Current race time
        let bestTime = localStorage.getItem('vibejet_best_time') || null; // Best time from storage
        let isRacing = false; // Racing mode active
        let powerups = []; // Array of power-up objects
        let playerShield = false; // Shield power-up active
        let shieldEndTime = 0; // When shield expires

        // --- Initialization ---
        function init() {
            // Basic Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(CAMERA_BASE_FOV, window.innerWidth / window.innerHeight, 0.1, 20000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Modern tone mapping
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();

            // --- Post-processing Setup ---
            setupPostProcessing();

            // --- Get Loading Indicator ---
            loadingIndicator = document.getElementById('loading-indicator');

            // Lighting (Day/Night)
            skyLight = new THREE.HemisphereLight(0x87ceeb, 0x000000, 0.6); // Sky, Ground, Intensity
            scene.add(skyLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
            sunLight.position.set(0, 1000, 1000); // Initial position
            sunLight.castShadow = true;
            // Ultra high-quality shadows
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 100;
            sunLight.shadow.camera.far = 5000;
            sunLight.shadow.camera.left = -GROUND_SIZE / 2;
            sunLight.shadow.camera.right = GROUND_SIZE / 2;
            sunLight.shadow.camera.top = GROUND_SIZE / 2;
            sunLight.shadow.camera.bottom = -GROUND_SIZE / 2;
            sunLight.shadow.bias = -0.0001;
            sunLight.shadow.normalBias = 0.02;
            scene.add(sunLight);
            scene.add(sunLight.target); // Important for directional light targeting

            // Add fill light for better overall illumination
            const fillLight = new THREE.DirectionalLight(0x8899ff, 0.4);
            fillLight.position.set(-500, 300, -500);
            scene.add(fillLight);

            // Add rim/back light for dramatic aircraft silhouettes
            const rimLight = new THREE.DirectionalLight(0xffaa88, 0.5);
            rimLight.position.set(0, 500, -1000);
            scene.add(rimLight);

            // Fog
            scene.fog = new THREE.Fog(0xcccccc, 1000, 15000);

            // Ground
            // const groundGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
            // const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide });
            // const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            // ground.rotation.x = -Math.PI / 2;
            // ground.receiveShadow = true;
            // scene.add(ground);
            createGround();

            // Populate Landscape, Buildings
            populateLandscape();

            // Stars
            createStars();

            // --- Load Assets & Initialize ---
            loadResources(); // <--- Start loading resources

            // Player Aircraft
            // createPlayerAircraft(); // WRONG PLACE - should be in initializeGame
            // Controls Setup
            // setupControls(); // WRONG PLACE - should be in initializeGame
            // WebSocket Setup
            // setupWebSocket(); // WRONG PLACE - should be in initializeGame

            // Handle Window Resize
            window.addEventListener('resize', onWindowResize, false);

            // Start Animation Loop (will be started later in initializeGame)
            // animate();
        }

        function setupPostProcessing() {
            // Create composer
            composer = new EffectComposer(renderer);

            // Add render pass
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Add SSAO (Screen Space Ambient Occlusion) for realistic shadows
            ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
            ssaoPass.kernelRadius = 16;
            ssaoPass.minDistance = 0.001;
            ssaoPass.maxDistance = 0.1;
            composer.addPass(ssaoPass);

            // Add bloom effect for glowing lights and afterburner
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,  // strength
                0.4,  // radius
                0.85  // threshold
            );
            composer.addPass(bloomPass);

            // Add speed lines effect (radial blur when boosting)
            createSpeedLinesShader();

            // Add SMAA (Enhanced Anti-aliasing)
            const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
            composer.addPass(smaaPass);

            // Output pass for proper color space
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        function createSpeedLinesShader() {
            // Custom shader for speed lines / radial blur effect
            const speedLinesShader = {
                uniforms: {
                    'tDiffuse': { value: null },
                    'intensity': { value: 0.0 },
                    'center': { value: new THREE.Vector2(0.5, 0.5) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float intensity;
                    uniform vec2 center;
                    varying vec2 vUv;

                    void main() {
                        vec2 dir = vUv - center;
                        float dist = length(dir);
                        vec2 offset = dir * dist * intensity * 0.05;

                        vec4 color = vec4(0.0);
                        float total = 0.0;

                        // Sample multiple times along the radial direction for motion blur
                        for(float i = 0.0; i < 10.0; i++) {
                            float t = i / 10.0;
                            color += texture2D(tDiffuse, vUv - offset * t);
                            total += 1.0;
                        }

                        gl_FragColor = color / total;
                    }
                `
            };

            speedLinesPass = new ShaderPass(speedLinesShader);
            speedLinesPass.enabled = true;
            composer.addPass(speedLinesPass);
        }

        function showLoadingIndicator(show) {
            if (loadingIndicator) {
                loadingIndicator.style.display = show ? 'block' : 'none';
            }
        }

        // Loading for the aircraft model alongside  the road texture
        function loadResources() {
            showLoadingIndicator(true);
            // Use ONE loading manager for all resources if possible
            loadingManager = new THREE.LoadingManager(
                // --- Manager onLoad ---
                () => {
                    console.log("All resources loaded.");
                    initializeGame(); // Initialize game ONLY after everything loads
                },
                // --- Manager onProgress (Optional) ---
                (url, itemsLoaded, itemsTotal) => {
                    // console.log(`Loading file: ${url} (${itemsLoaded}/${itemsTotal})`);
                    // You could update loading indicator here:
                    // loadingIndicator.textContent = `Loading ${itemsLoaded}/${itemsTotal}...`;
                },
                // --- Manager onError ---
                (url) => {
                    console.error('There was an error loading ' + url);
                    showLoadingIndicator(false);
                    // Maybe display a more specific error?
                    displayError("Failed to load critical resources. Please check console and refresh.");
                }
            );

            // --- Load Aircraft Model ---
            const gltfLoader = new GLTFLoader(loadingManager);
            gltfLoader.load(MODEL_URL, (gltf) => {
                console.log("Aircraft model loaded.");
                loadedModelTemplate = gltf.scene; // Store the loaded scene
                loadedModelTemplate.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE); // Apply settings to the template once
                // Ensure model casts shadows (traverse the loaded scene)
                loadedModelTemplate.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        // Optional: Also allow receiving shadows if needed
                        // child.receiveShadow = true;
                    }
                });

                // --- IMPORTANT: Rotate template if needed ---
                // Models might not be oriented along +Z by default.
                // Add rotations here to align the template correctly.

                // Previous attempts:
                // loadedModelTemplate.rotateX(Math.PI);
                // loadedModelTemplate.rotateY(Math.PI);
                // loadedModelTemplate.rotateZ(Math.PI);

                // New approach: Set Euler angles directly for better control
                // This will set the model to have its nose pointing forward (+Z)
                // and its top side facing up (+Y)
                loadedModelTemplate.rotation.set(0, Math.PI, 0);

                // Uncomment alternatives if the above doesn't work:
                // Alternative 1:
                // loadedModelTemplate.rotation.set(0, 0, 0); // Reset orientation
                // Alternative 2: 
                // loadedModelTemplate.rotation.set(Math.PI/2, 0, 0); // Pitch 90 degrees
            } /* no progress/error needed here, manager handles it */);

            // --- Load Road Texture ---
            const textureLoader = new THREE.TextureLoader(loadingManager);
            textureLoader.load(ROAD_TEXTURE_URL, (texture) => {
                console.log("Road texture loaded.");
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                roadTexture = texture; // Store loaded texture globally
            });

            // --- Load Ground Texture (already uses its own loader, but could be added to manager) ---
            // Keep the existing createGround function which has its own loader for now
            // Alternatively, move ground texture loading here and pass texture to createGround


            /*
            loadingManager = new THREE.LoadingManager();
            const loader = new GLTFLoader(loadingManager);

            loader.load(
                MODEL_URL,
                // --- Success Callback ---
                (gltf) => {
                    console.log("Model loaded successfully.");
                    loadedModelTemplate = gltf.scene; // Store the loaded scene

                    // --- Apply settings to the template once ---
                    loadedModelTemplate.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);

                    // Ensure model casts shadows (traverse the loaded scene)
                    loadedModelTemplate.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            // Optional: Also allow receiving shadows if needed
                            // child.receiveShadow = true;
                        }
                    });

                    // --- IMPORTANT: Rotate template if needed ---
                    // Models might not be oriented along +Z by default.
                    // Add rotations here to align the template correctly.
                    
                    // Previous attempts:
                    // loadedModelTemplate.rotateX(Math.PI);
                    // loadedModelTemplate.rotateY(Math.PI);
                    // loadedModelTemplate.rotateZ(Math.PI);
                    
                    // New approach: Set Euler angles directly for better control
                    // This will set the model to have its nose pointing forward (+Z)
                    // and its top side facing up (+Y)
                    loadedModelTemplate.rotation.set(0, Math.PI, 0);
                    
                    // Uncomment alternatives if the above doesn't work:
                    // Alternative 1:
                    // loadedModelTemplate.rotation.set(0, 0, 0); // Reset orientation
                    
                    // Alternative 2: 
                    // loadedModelTemplate.rotation.set(Math.PI/2, 0, 0); // Pitch 90 degrees

                    initializeGame(); // Proceed with game setup
                },
                // --- Progress Callback (Optional) ---
                (xhr) => {
                    // console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    // You could update the loading indicator text here
                },
                // --- Error Callback ---
                (error) => {
                    console.error('An error happened during model loading:', error);
                    showLoadingIndicator(false);
                    displayError("Failed to load aircraft model. Please check console and refresh.");
                }
            );
            */
        }

        function initializeGame() {
            // initializeGame was modified slightly to ensure it ONLY runs via the LoadingManager

            // Check if essential resources are loaded (redundant if manager's onLoad is used, but safe)
            if (!loadedModelTemplate || !roadTexture) {
                console.error("Essential resources not ready for initialization!");
                // Display error maybe? The manager's onError should ideally catch this.
                return;
            }

            // Only hide indicator once we are truly ready to init
            showLoadingIndicator(false); // Hide loading indicator
            console.log("Initializing game...");

            // --- Create Player Aircraft (now clones the loaded model) ---
            createPlayerAircraft();

            // --- Setup Controls ---
            setupControls();

            // --- WebSocket Setup ---
            setupWebSocket();

            createTrees(TREE_COUNT);

            createClouds();

            createRoads();

            createJetTrailParticles();

            createCheckpoints();

            createPowerups();

            setupRaceControls();

            // --- Start Animation Loop ---
            animate(); // <-- START the loop HERE
            console.log("Game initialized and animation loop started.");
        }

        function createBuildings() {
            const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8, metalness: 0.2 });
            const buildingGeometry = new THREE.BoxGeometry(1, 1, 1); // Base geometry

            for (let i = 0; i < BUILDING_COUNT; i++) {
                const height = Math.random() * (MAX_BUILDING_HEIGHT - MIN_BUILDING_HEIGHT) + MIN_BUILDING_HEIGHT;
                const width = Math.random() * 40 + 20;
                const depth = Math.random() * 40 + 20;

                const building = new THREE.Mesh(buildingGeometry, buildingMaterial.clone()); // Clone material if needed
                building.scale.set(width, height, depth);

                const x = (Math.random() - 0.5) * (GROUND_SIZE * 0.9); // Keep away from edge slightly
                const z = (Math.random() - 0.5) * (GROUND_SIZE * 0.9);
                building.position.set(x, height / 2, z);

                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);

                // Store bounding box for collision
                const box = new THREE.Box3().setFromObject(building);
                buildingBoundingBoxes.push(box);
            }
        }

        // This will be similar to the old `createBuildings`, but with more variation.
        function createSkyscrapers(count) {
            console.log("Creating skyscrapers...");
            const buildingGeometry = new THREE.BoxGeometry(1, 1, 1); // Base geometry

            // OPTIMIZED: Create material pools (reuse instead of creating new materials for each building)
            const glassMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(0.55, 0.3, 0.7),
                roughness: 0.1,
                metalness: 0.9,
                envMapIntensity: 1.5
            });

            const concreteMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(0, 0, 0.5),
                roughness: 0.95,
                metalness: 0.05
            });

            const semiReflectiveMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(0.05, 0.1, 0.6),
                roughness: 0.5,
                metalness: 0.5,
                envMapIntensity: 0.8
            });

            // Material pool - reuse these materials
            const materials = [glassMaterial, concreteMaterial, semiReflectiveMaterial];

            for (let i = 0; i < count; i++) {
                const height = MIN_BUILDING_HEIGHT + Math.random() * (MAX_BUILDING_HEIGHT - MIN_BUILDING_HEIGHT);
                // More width/depth variation
                const width = Math.random() * 50 + 20;
                const depth = Math.random() * 50 + 20;

                // Pick one of the shared materials (no allocation overhead)
                const material = materials[Math.floor(Math.random() * materials.length)];

                const building = new THREE.Mesh(buildingGeometry, material);
                building.scale.set(width, height, depth);

                const x = (Math.random() - 0.5) * (GROUND_SIZE * 0.9);
                const z = (Math.random() - 0.5) * (GROUND_SIZE * 0.9);
                const y = getTerrainHeight(x, z) + height / 2; // Place base on terrain

                // Avoid placing skyscrapers too low in valleys
                if (y - height / 2 < 0) continue; // Skip if base is below Y=0

                building.position.set(x, y, z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);

                // Store bounding box (important: update position based on terrain height)
                const box = new THREE.Box3().setFromObject(building);
                buildingBoundingBoxes.push(box);
            }
            console.log("Skyscrapers created.");
        }

        // Generates clusters of smaller boxes.
        function createHouses(clusterCount) {
            console.log("Creating house clusters...");
            const houseMaterial = new THREE.MeshStandardMaterial({ color: 0xcc6633, roughness: 0.9 }); // Brownish color
            const houseGeometry = new THREE.BoxGeometry(1, 1, 1);
            const housesPerCluster = 10 + Math.floor(Math.random() * 15);
            const clusterRadius = 150;

            for (let c = 0; c < clusterCount; c++) {
                // Find a suitable center point for the cluster (on relatively flat ground?)
                let clusterX, clusterZ, clusterY;
                do {
                    clusterX = (Math.random() - 0.5) * (GROUND_SIZE * 0.8);
                    clusterZ = (Math.random() - 0.5) * (GROUND_SIZE * 0.8);
                    clusterY = getTerrainHeight(clusterX, clusterZ);
                } while (clusterY < 5 || clusterY > TERRAIN_AMPLITUDE * 0.5); // Avoid water/peaks

                for (let i = 0; i < housesPerCluster; i++) {
                    const height = 5 + Math.random() * 5;
                    const width = 8 + Math.random() * 8;
                    const depth = 8 + Math.random() * 8;

                    const house = new THREE.Mesh(houseGeometry, houseMaterial); // Can reuse material
                    house.scale.set(width, height, depth);

                    // Place relative to cluster center
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * clusterRadius;
                    const x = clusterX + Math.cos(angle) * radius;
                    const z = clusterZ + Math.sin(angle) * radius;
                    const y = getTerrainHeight(x, z) + height / 2; // Place base on terrain

                    // Simple check to avoid houses floating too high above cluster center or sinking too low
                    if (Math.abs(y - height/2 - clusterY) > 20) continue; // Skip if terrain is too steep here

                    house.position.set(x, y, z);
                    house.rotation.y = Math.random() * Math.PI; // Random orientation
                    house.castShadow = true;
                    house.receiveShadow = true;
                    scene.add(house);

                    const box = new THREE.Box3().setFromObject(house);
                    buildingBoundingBoxes.push(box); // Add to collisions
                }
            }
            console.log("House clusters created.");
        }

        // Creates flat, blue circles on the terrain.
        function createPonds(count) {
            console.log("Creating ponds...");
            const pondMaterial = new THREE.MeshStandardMaterial({
                color: 0x3366aa,
                roughness: 0.2,
                metalness: 0.1,
                transparent: true,
                opacity: 0.8
            });
            const pondSegments = 32; // Make circles smooth

            for (let i = 0; i < count; i++) {
                const radius = 50 + Math.random() * 100;
                const pondGeometry = new THREE.CircleGeometry(radius, pondSegments);

                let x, z, y;
                // Try to find lower ground for ponds
                do {
                    x = (Math.random() - 0.5) * (GROUND_SIZE * 0.9);
                    z = (Math.random() - 0.5) * (GROUND_SIZE * 0.9);
                    y = getTerrainHeight(x, z);
                } while (y > TERRAIN_AMPLITUDE * 0.3); // Prefer lower areas

                const pond = new THREE.Mesh(pondGeometry, pondMaterial);
                // Position slightly below terrain height and rotate flat
                pond.position.set(x, y - 0.5, z); // Sink slightly
                pond.rotation.x = -Math.PI / 2;
                // Ponds don't cast shadows, but can receive them
                pond.receiveShadow = true;
                scene.add(pond);
            }
            console.log("Ponds created.");
        }

        function Castle() {
            console.log("Creating castle...");
            const castleGroup = new THREE.Group();
            
            // Main castle body - large central keep
            const keepGeometry = new THREE.BoxGeometry(40, 60, 40);
            const stoneMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080,
                flatShading: true
            });
            const keep = new THREE.Mesh(keepGeometry, stoneMaterial);
            keep.position.y = 30;
            castleGroup.add(keep);
            
            // Create text banner above castle door
            const createCastleTextTexture = () => {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                
                const context = canvas.getContext('2d');
                
                // Clear canvas with transparent background
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // Text
                context.font = 'bold 36px system-ui';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText('CEDRIC.AI', canvas.width / 2, canvas.height / 3);
                context.fillText('CASTLE', canvas.width / 2, canvas.height * 2/3);
                
                return new THREE.CanvasTexture(canvas);
            };

            // Create banner with castle text
            const castleBannerGeometry = new THREE.PlaneGeometry(30, 15);
            const castleBannerMaterial = new THREE.MeshBasicMaterial({ 
                map: createCastleTextTexture(),
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                fog: false
            });
            const castleBanner = new THREE.Mesh(castleBannerGeometry, castleBannerMaterial);
            
            // Position banner above castle door
            castleBanner.position.set(0, 40, 20.1); // Slightly in front of castle wall
            castleGroup.add(castleBanner);

            // Four corner towers
            const towerGeometry = new THREE.CylinderGeometry(6, 8, 70, 8);
            const towerPositions = [
                [-22, 35, -22],
                [22, 35, -22],
                [-22, 35, 22],
                [22, 35, 22]
            ];
            
            towerPositions.forEach((pos, index) => {
                const tower = new THREE.Mesh(towerGeometry, stoneMaterial);
                tower.position.set(...pos);
                castleGroup.add(tower);
                
                // Add conical roof to each tower
                const roofGeometry = new THREE.ConeGeometry(8, 15, 8);
                const roofMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8B4513
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(pos[0], pos[1] + 42, pos[2]);
                castleGroup.add(roof);
            });
            
            // Add crenellations
            for(let x = -18; x <= 18; x += 4) {
                for(let z = -18; z <= 18; z += 4) {
                    if(x === -18 || x === 18 || z === -18 || z === 18) {
                        const merlon = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 4, 3),
                            stoneMaterial
                        );
                        merlon.position.set(x, 62, z);
                        castleGroup.add(merlon);
                    }
                }
            }
            
            // extra
            castleGroup.scale.set(3.0, 3.0, 3.0);

            // Position the castle
            // castleGroup.position.set(100, 35.2, -300);
            castleGroup.position.set(2000, 10, 1000);
            return castleGroup;
        }

        function createCastle() {
            // Add after other scene setup code
            const castle = Castle();
            scene.add(castle);
            console.log("Castle created.");
        }

        function BigHouse() {
            console.log("Creating big house...");
            // houses with pointy roofs
            const houseGroup = new THREE.Group();
            const scale = 10; // TODO: change to use houseGroup scale later
            
            // Random house size
            const width = (4 * scale) + Math.random() * 4;
            const height = (6 * scale) + Math.random() * 8;
            const depth = (4 * scale) + Math.random() * 4;
            
            // Main building
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(
                    0.7 + Math.random() * 0.3,
                    0.7 + Math.random() * 0.3,
                    0.7 + Math.random() * 0.3
                )
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height/2;
            houseGroup.add(building);
            
            // Roof (pyramid style)
            const roofHeight = height * 0.3;
            const roofGeometry = new THREE.ConeGeometry(width * 0.8, roofHeight, 4);
            const roofMaterial = new THREE.MeshPhongMaterial({
                color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D // Brown variations
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = height + roofHeight/2;
            roof.rotation.y = Math.PI/4; // Rotate 45 degrees for better look
            houseGroup.add(roof);
            
            // Windows
            const windowSize = width * 0.2;
            const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.1);
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaff,
                emissive: 0x444444
            });
            
            // Add multiple windows
            const windowPositions = [
                [-width/4, height/2, depth/2],
                [width/4, height/2, depth/2],
                [-width/4, height*0.75, depth/2],
                [width/4, height*0.75, depth/2]
            ];
            
            windowPositions.forEach(pos => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(...pos);
                houseGroup.add(window);
            });
            
            // Door
            const doorWidth = width * 0.3;
            const doorHeight = height * 0.4;
            const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B4513
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, doorHeight/2, depth/2);
            houseGroup.add(door);
            
            return houseGroup;
        }

        // Create multiple houses
        function createBigHouse(count) {
            const houses = [];

            for(let i = 0; i < count; i++) {
                const house = BigHouse();

                const x = (Math.random() - 0.5) * (GROUND_SIZE * 0.9); // Keep away from edge slightly
                const z = (Math.random() - 0.5) * (GROUND_SIZE * 0.9);
                const y = getTerrainHeight(x, z); // Place base slightly above ground? Or adjust based on shape size
                house.position.set(x, y, z);

                house.rotation.y = Math.random() * Math.PI * 2; // Random rotation
                houses.push(house);
                scene.add(house);
            }

            console.log("Big houses created.");
        }

        // Robot on land
        function createGiantRobot() {
            console.log("Creating giant robot...");

            // Create a floating robot
            const robotGroup = new THREE.Group();
            
            // Robot body
            const bodyGeometry = new THREE.BoxGeometry(10, 14, 6);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0xb894db, // Blue color
                shininess: 70,
                fog: false
            });
            const robotBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            robotGroup.add(robotBody);
            
            // Robot head
            const headGeometry = new THREE.BoxGeometry(8, 6, 6);
            const headMaterial = new THREE.MeshPhongMaterial({
                color: 0x935dc9, // Darker blue
                shininess: 70,
                fog: false
            });
            const robotHead = new THREE.Mesh(headGeometry, headMaterial);
            robotHead.position.y = 10; // Position on top of body
            robotGroup.add(robotHead);
            
            // Robot eyes
            const eyeGeometry = new THREE.SphereGeometry(1, 16, 16);
            const eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000, // Red eyes
                emissive: 0xff0000,
                emissiveIntensity: 0.8,
                fog: false
            });
            
            // Left eye
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-2, 10, 3);
            robotGroup.add(leftEye);
            
            // Right eye
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(2, 10, 3);
            robotGroup.add(rightEye);
            
            // Robot arms
            const armGeometry = new THREE.BoxGeometry(2, 8, 2);
            const armMaterial = new THREE.MeshPhongMaterial({
                color: 0xb894db,
                shininess: 70,
                fog: false
            });
            
            // Left arm
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-6, 0, 0);
            robotGroup.add(leftArm);
            
            // Right arm
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(6, 0, 0);
            robotGroup.add(rightArm);
            
            // Robot legs
            const legGeometry = new THREE.BoxGeometry(3, 8, 3);
            const legMaterial = new THREE.MeshPhongMaterial({
                color: 0x935dc9,
                shininess: 70,
                fog: false
            });
            
            // Left leg
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-3, -11, 0);
            robotGroup.add(leftLeg);
            
            // Right leg
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(3, -11, 0);
            robotGroup.add(rightLeg);
            
            // Create LINDY.AI banner
            const bannerCanvas = document.createElement('canvas');
            const bannerContext = bannerCanvas.getContext('2d');
            bannerCanvas.width = 512;
            bannerCanvas.height = 128;
            
            // Set banner background
            bannerContext.fillStyle = '#935dc9'; // Blue background
            bannerContext.fillRect(0, 0, bannerCanvas.width, bannerCanvas.height);
            
            // Add text
            bannerContext.font = 'bold 60px system-ui';
            bannerContext.textAlign = 'center';
            bannerContext.textBaseline = 'middle';
            bannerContext.fillStyle = 'white';
            bannerContext.fillText('NEO.AI', bannerCanvas.width / 2, bannerCanvas.height / 2);
            
            const bannerTexture = new THREE.CanvasTexture(bannerCanvas);
            const bannerMaterial = new THREE.MeshBasicMaterial({
                map: bannerTexture,
                transparent: true,
                side: THREE.DoubleSide,
                fog: false
            });
            
            const bannerGeometry = new THREE.PlaneGeometry(16, 4);
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
            banner.position.y = 18; // Position above the robot
            robotGroup.add(banner);
            
            // extra
            robotGroup.scale.set(8.0, 8.0, 8.0);

            const x = -800;
            const z = 2000 > GROUND_SIZE ? GROUND_SIZE * 0.9 : 2000;
            const y = getTerrainHeight(x, z) + 120; // Place base slightly above ground? Or adjust based on shape size
            robotGroup.position.set(x, y, z);

            robotGroup.rotation.y = 15.0;
            
            scene.add(robotGroup);

            console.log("Giant robot created.");
        }

        // Add after other scene setup code, before the animation loop
        function Mountain() {
            console.log("Creating mountain...");

            let mountainSign;

            const mountainGroup = new THREE.Group();
            
            // Create main mountain peak
            const mountainGeometry = new THREE.ConeGeometry(100, 200, 6);
            const mountainMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B4513, // Brown base color
                flatShading: true
            });
            
            const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
            mountain.position.y = 100; // Half height to place base at ground level
            mountainGroup.add(mountain);

            // Create Hollywood-style sign text texture
            const createMountainSignTextTexture = () => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 1024;
                canvas.height = 256;
                
                // Transparent background
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // Text style
                context.font = 'bold 60px system-ui';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                // Load custom font
                const font = new FontFace('SF Hollywood Hills', 'url(/assets/hollywood.ttf)');
                font.load().then(() => {
                    document.fonts.add(font);
                    
                    // Add black stroke
                    context.font = 'bold 60px "SF Hollywood Hills"';
                    context.strokeStyle = '#000000';
                    
                    // Add white fill
                    context.fillStyle = '#FFFFFF';
                    context.fillText('CEDRICCHEE.COM', canvas.width/2, canvas.height/2);
                });
                return new THREE.CanvasTexture(canvas);
            };

            // Create sign banner
            const mountainSignGeometry = new THREE.PlaneGeometry(120, 30);
            const mountainSignMaterial = new THREE.MeshBasicMaterial({
                map: createMountainSignTextTexture(),
                transparent: true,
                side: THREE.DoubleSide
            });
            mountainSign = new THREE.Mesh(mountainSignGeometry, mountainSignMaterial);
            
            // Position sign on mountain slope
            mountainSign.position.set(-60, 70, 40);
            mountainSign.rotation.z=0;
            mountainSign.rotation.x=0;
            mountainSign.rotation.y=-1.1;
            mountainGroup.add(mountainSign);


            // Add snow cap
            const snowCapGeometry = new THREE.ConeGeometry(40, 50, 6);
            const snowMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF, // White snow
                flatShading: true
            });
            
            const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
            snowCap.position.y = 175; // Position at top of mountain
            mountainGroup.add(snowCap);
            
            // Add some smaller peaks around the main one
            const smallPeakPositions = [
                [-50, -30, -40],
                [60, -50, 30],
                [-30, -60, 50]
            ];
            
            smallPeakPositions.forEach(pos => {
                const smallPeakHeight = 80 + Math.random() * 60;
                const smallPeakGeometry = new THREE.ConeGeometry(30 + Math.random() * 20, smallPeakHeight, 5);
                const smallPeak = new THREE.Mesh(smallPeakGeometry, mountainMaterial);
                
                smallPeak.position.set(
                    pos[0],
                    smallPeakHeight / 2, // Half height to place base at ground level
                    pos[1]
                );
                
                // Random rotation for variety
                smallPeak.rotation.y = Math.random() * Math.PI;
                mountainGroup.add(smallPeak);
                
                // Add small snow caps to some peaks
                if (Math.random() > 0.3) {
                    const smallSnowGeometry = new THREE.ConeGeometry(15, 20, 5);
                    const smallSnow = new THREE.Mesh(smallSnowGeometry, snowMaterial);
                    smallSnow.position.y = smallPeakHeight * 0.4;
                    smallPeak.add(smallSnow);
                }
            });
            
            // Add trees on the lower slopes
            for (let i = 0; i < 50; i++) {
                // Calculate position on the mountain slope
                const angle = Math.random() * Math.PI * 2;
                const distance = 70 + Math.random() * 100; // Increased minimum and maximum distance
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                // Calculate height based on distance from center (higher = lower on slope)
                const height = 10 + Math.random() * 15;
                
                // Create tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(2, 3, height, 8);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                // Create tree top (pine tree style)
                const treeTopGeometry = new THREE.ConeGeometry(8, height * 1.5, 8);
                const treeTopMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x006400, // Dark green
                    flatShading: true
                });
                const treeTop = new THREE.Mesh(treeTopGeometry, treeTopMaterial);
                treeTop.position.y = height * 0.75;
                
                // Create tree group
                const tree = new THREE.Group();
                tree.add(trunk);
                tree.add(treeTop);
                
                // Position tree on mountain slope
                tree.position.set(x, height/2, z);
                
                // Random rotation and slight tilt based on slope
                tree.rotation.y = Math.random() * Math.PI * 2;
                const slopeTilt = distance / 100; // More tilt further from center
                tree.rotation.x = (Math.random() - 0.5) * 0.2 * slopeTilt;
                tree.rotation.z = (Math.random() - 0.5) * 0.2 * slopeTilt;
                
                mountainGroup.add(tree);
            }

            // Position the mountain in some nice area
            mountainGroup.position.set(-2000, 0, -800);
            
            // extra
            mountainGroup.scale.set(2.0, 2.0, 2.0);
            mountainGroup.rotation.y = 15.0;

            return mountainGroup;
        }

        // Create and add mountain to scene
        function createMountain() {
            const mountain = Mountain();
            scene.add(mountain);

            console.log("Mountain created.");
        }

        // Create UFO with logo
        function UFO() {
            console.log("Creating UFO ...");

            const ufoGroup = new THREE.Group();
            
            // Create the main UFO body (saucer shape)
            const ufoBodyGeometry = new THREE.SphereGeometry(10, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            
            // Load Basecamp logo texture for the UFO body
            const ufoTextureLoader = new THREE.TextureLoader();
            // const ufoTexture = ufoTextureLoader.load('/assets/logorythms.png');
            
            // Configure texture to repeat in a pattern
            // ufoTexture.wrapS = THREE.RepeatWrapping;
            // ufoTexture.wrapT = THREE.RepeatWrapping;
            // ufoTexture.repeat.set(5, 4);
            
            const ufoBodyMaterial = new THREE.MeshPhongMaterial({
                // map: ufoTexture,
                color: 0xC0C0C0, // Silver/metallic color
                shininess: 80,
                fog: false
            });
            
            const ufoBody = new THREE.Mesh(ufoBodyGeometry, ufoBodyMaterial);
            ufoBody.scale.y = 0.3; // Flatten the sphere to make it saucer-like
            ufoGroup.add(ufoBody);
            // Create the bottom part of the UFO with the same texture
            const ufoBottomGeometry = new THREE.SphereGeometry(7, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 4);
            const ufoBottomMaterial = new THREE.MeshPhongMaterial({
                // map: ufoTexture,
                color: 0xC0C0C0, // Silver/metallic color
                shininess: 60,
                fog: false
            });
            const ufoBottom = new THREE.Mesh(ufoBottomGeometry, ufoBottomMaterial);
            ufoBottom.position.y = 0;;
            ufoBottom.scale.y = 0.5;
            ufoGroup.add(ufoBottom);
            


            // Create the cockpit/dome on top of the UFO
            const ufoCockpitGeometry = new THREE.SphereGeometry(4, 32, 32);

            // Load the globe texture for the cockpit
            const ufoGlobeTextureLoader = new THREE.TextureLoader();
            // const ufoGlobeTexture = ufoGlobeTextureLoader.load('/assets/logorythms_globe.png');

            // Configure the texture to wrap properly around the sphere
            // ufoGlobeTexture.wrapS = THREE.RepeatWrapping;
            // ufoGlobeTexture.wrapT = THREE.ClampToEdgeWrapping; // Clamp vertical to avoid stretching at poles
            // ufoGlobeTexture.repeat.set(2, 1);

            const ufoCockpitMaterial = new THREE.MeshPhongMaterial({
                // map: ufoGlobeTexture,
                transparent: true,
                opacity: 0.9, // Slightly transparent for a glass-like effect
                shininess: 100,
                fog: false
            });

            const ufoCockpit = new THREE.Mesh(ufoCockpitGeometry, ufoCockpitMaterial);
            ufoGroup.add(ufoCockpit);

            
            ufoCockpit.rotation.y=0.1;
            ufoCockpit.position.y=3;
            
            
            // Add a top plate for the main disc's bottom side
            const ufoTopBottomPlateGeometry = new THREE.CircleGeometry(10, 32);
            const ufoTopBottomPlateMaterial = new THREE.MeshPhongMaterial({
                // map: ufoTexture,
                color: 0xC0C0C0, // Silver/metallic color
                shininess: 60,
                side: THREE.DoubleSide,
                fog: false
            });
            const ufoTopBottomPlate = new THREE.Mesh(ufoTopBottomPlateGeometry, ufoTopBottomPlateMaterial);
            ufoTopBottomPlate.position.y = 0;
            ufoTopBottomPlate.rotation.x = Math.PI / 2; // Make it horizontal
            ufoGroup.add(ufoTopBottomPlate);
            
            // Create lights under the UFO
            const ufoLightPositions = [
                [5, -2, 0], [-5, -2, 0], [0, -2, 5], [0, -2, -5]
            ];
            
            ufoLightPositions.forEach(pos => {
                const ufoLightGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const ufoLightMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF, // Cyan color
                    fog: false
                });
                const ufoLight = new THREE.Mesh(ufoLightGeometry, ufoLightMaterial);
                ufoLight.position.set(pos[0], pos[1], pos[2]);
                ufoGroup.add(ufoLight);
            });
            
            // Position the UFO in the scene
            // ufoGroup.position.set(200, 1000, 5000);
            ufoGroup.position.set(0, 40, 70);

            return ufoGroup;
        }

        function createUFO() {
            const ufoGroup = UFO();
            // extra
            ufoGroup.scale.set(2.0, 2.0, 2.0);
            scene.add(ufoGroup);

            // Animation for the UFO
            const ufoAnimation = () => {
                const ufoTime = Date.now() * 0.001;
                
                // Circular flight pattern closer to player aircraft (0,0)
                ufoGroup.position.x = 0 + Math.sin(ufoTime * 0.2) * 500;
                ufoGroup.position.z = -70 + Math.cos(ufoTime * 0.2) * 500;
                
                // Lower flying height between 50-100
                ufoGroup.position.y = 200 + Math.sin(ufoTime * 0.5) * 10;
                
                // Slight tilting in the direction of movement
                ufoGroup.rotation.z = Math.sin(ufoTime * 0.2) * 0.1;
                ufoGroup.rotation.x = Math.cos(ufoTime * 0.2) * 0.1;
                
                // Update UFO sound based on position
                // updateUFOSound();
                
                requestAnimationFrame(ufoAnimation);
            };

            ufoAnimation();

            console.log("UFO created.");
        }

        function Blimp(mainBodyColor) {
            console.log('Creating blimp ...');

            // Create blimp group
            const blimp3Group = new THREE.Group();

            // Load texture for blimp body
            // const blimp3Texture = new THREE.TextureLoader().load('/assets/logorythms.png');
            // blimp3Texture.wrapS = THREE.RepeatWrapping;
            // blimp3Texture.wrapT = THREE.RepeatWrapping;
            // blimp3Texture.repeat.set(5, 3);

            // Main blimp body (ellipsoid) - increased length by 1.5x
            const blimp3MainBodyGeometry = new THREE.SphereGeometry(20, 32, 32);
            blimp3MainBodyGeometry.scale(1, 1, 2.7); // Changed from 1.8 to 2.7 (1.5x longer)
            const blimp3MainBodyMaterial = new THREE.MeshPhongMaterial({ 
                // map: blimp3Texture,
                color: mainBodyColor
            });
            const blimp3MainBody = new THREE.Mesh(blimp3MainBodyGeometry, blimp3MainBodyMaterial);
            blimp3Group.add(blimp3MainBody);

            // Blimp tail section - moved further back
            const blimp3TailGeometry = new THREE.ConeGeometry(15, 20, 32);
            blimp3TailGeometry.rotateX(Math.PI / 2);
            blimp3TailGeometry.translate(0, 0, 45); // Changed from 30 to 45 to match the longer body
            const blimp3TailMaterial = new THREE.MeshPhongMaterial({ 
                // map: blimp3Texture,
                color: 0x00008B
            });
            const blimp3Tail = new THREE.Mesh(blimp3TailGeometry, blimp3TailMaterial);
            blimp3Group.add(blimp3Tail);

            // Gondola (cabin beneath blimp)
            const blimp3GondolaGeometry = new THREE.BoxGeometry(10, 5, 7);
            const blimp3GondolaMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 }); // Dark grey
            const blimp3Gondola = new THREE.Mesh(blimp3GondolaGeometry, blimp3GondolaMaterial);
            blimp3Gondola.position.y = -20;
            blimp3Group.add(blimp3Gondola);

            // Fins (rudders)
            const blimp3FinGeometry = new THREE.ConeGeometry(8, 15, 4);
            blimp3FinGeometry.rotateX(Math.PI / 2);

            const blimp3FinMaterial = new THREE.MeshPhongMaterial({ 
                // map: blimp3Texture,
                color: 0xFF0000
            });

            // Vertical fin - moved further back
            const blimp3VerticalFin = new THREE.Mesh(blimp3FinGeometry, blimp3FinMaterial);
            blimp3VerticalFin.position.set(0, 0, 50); // Changed from 35 to 50
            blimp3VerticalFin.rotation.x = Math.PI / 2;
            blimp3Group.add(blimp3VerticalFin);

            // Horizontal fin - moved further back
            const blimp3HorizontalFin = new THREE.Mesh(blimp3FinGeometry, blimp3FinMaterial);
            blimp3HorizontalFin.position.set(0, 0, 50); // Changed from 35 to 50
            blimp3HorizontalFin.rotation.z = Math.PI / 2;
            blimp3Group.add(blimp3HorizontalFin);
            
            return blimp3Group;
        }

        function createBlimp() {
            // 
            // First blimp
            // 
            const blimp3Group = Blimp(0xFFFF00);
            // Position the blimp high in the sky
            blimp3Group.position.set(-550, 500, -800); // Fixed position, altitude, negative Z moves it forward
            // Rotate the blimp 90 degrees leftwards (counter-clockwise around Y axis)
            blimp3Group.rotation.y=-1.5;
            scene.add(blimp3Group);

            // 
            // Second blimp
            // 
            const blimp3Group2 = Blimp(0xFF0000);
            blimp3Group2.position.set(1000, 1000, -2000);
            blimp3Group2.rotation.y=1.5;
            scene.add(blimp3Group2);

            // 
            // Third blimp
            // 
            const blimp3Group3 = Blimp(0xFF007F);
            blimp3Group3.position.set(500, 600, 1000);
            blimp3Group3.rotation.y=2.0;
            scene.add(blimp3Group3);

            console.log('Blimp created');
        }

        // Places a few large, distinct procedural shapes.
        function createLandmarks(count) {
            console.log("Creating landmarks...");
            const landmarkMaterials = [
                new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 }), // Gold
                new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.7 }), // Red
                new THREE.MeshStandardMaterial({ color: 0x44ff44, roughness: 0.7 }), // Green
                new THREE.MeshStandardMaterial({ color: 0xaaaaff, roughness: 0.1, metalness: 0.2, transmission: 0.8, transparent: true, opacity: 0.9 }) // Crystal/Glass
            ];
            const landmarkGeometries = [
                new THREE.IcosahedronGeometry(30, 0), // Size 30
                new THREE.TorusKnotGeometry(20, 8, 100, 16), // Size ~28
                new THREE.DodecahedronGeometry(25, 0), // Size 25
                new THREE.SphereGeometry(40, 32, 16) // Size 40
            ];

            for (let i = 0; i < count; i++) {
                const geometry = landmarkGeometries[i % landmarkGeometries.length];
                const material = landmarkMaterials[i % landmarkMaterials.length];
                const landmark = new THREE.Mesh(geometry, material);

                // Place them further apart
                const x = (Math.random() - 0.5) * (GROUND_SIZE * 0.7);
                const z = (Math.random() - 0.5) * (GROUND_SIZE * 0.7);
                const y = getTerrainHeight(x, z) + 40; // Place base slightly above ground? Or adjust based on shape size

                landmark.position.set(x, y, z);
                landmark.rotation.set(Math.random()*0.2, Math.random()*Math.PI*2, Math.random()*0.2);
                landmark.castShadow = true;
                landmark.receiveShadow = true;
                scene.add(landmark);

                // Add bounding box for collision
                const box = new THREE.Box3().setFromObject(landmark);
                buildingBoundingBoxes.push(box);
            }
            console.log("Landmarks created.");
        }

        function populateLandscape() {
            console.log("Populating landscape...");
            buildingBoundingBoxes = []; // <-- CLEAR bounding boxes before repopulating
            createSkyscrapers(BUILDING_COUNT); // Function to create tall buildings
            createHouses(20); // Function to create clusters of houses (e.g., 15 clusters)
            createPonds(30); // Function to create ponds
            // createLandmarks(10); // Function to create placeholder landmarks
            createCastle();
            createBigHouse(50);
            createGiantRobot();
            createMountain();
            createUFO();
            createBlimp();
            console.log("Landscape population complete.");
        }

        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, sizeAttenuation: true });
            const starVertices = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                const x = (Math.random() - 0.5) * 15000;
                const y = Math.random() * 5000 + 500; // Keep stars above a certain height
                const z = (Math.random() - 0.5) * 15000;
                // Ensure stars are far enough away
                if(Math.sqrt(x*x + y*y + z*z) > 1000) {
                     starVertices.push(x, y, z);
                } else {
                    i--; // retry if too close
                }
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function createGround() {
            const textureLoader = new THREE.TextureLoader();
            // Try local texture first (download from: https://threejs.org/examples/textures/terrain/grasslight-big.jpg)
            // If local file doesn't exist, will fall back to CDN, then to solid color
            const grassTextureUrl = 'assets/grasslight-big.jpg';

            console.log("Loading ground texture...");
            textureLoader.load(
                grassTextureUrl,
                // --- Success Callback (Texture Loaded) ---
                (texture) => {
                    console.log("Ground texture loaded.");
                    // Configure texture
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    const repeats = GROUND_SIZE / 100; // How many times texture repeats (adjust 100 based on texture size/look)
                    texture.repeat.set(repeats, repeats);

                    // --- Create Ground Geometry (Higher Segments) ---
                    const groundGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE, GROUND_SEGMENTS, GROUND_SEGMENTS);

                    // --- Modify Vertices for Hills ---
                    const positionAttribute = groundGeometry.attributes.position;
                    const vertex = new THREE.Vector3();

                    console.log("Generating terrain geometry...");
                    for (let i = 0; i < positionAttribute.count; i++) {
                        // Get the original vertex position (x, y, z=0) from the flat plane
                        vertex.fromBufferAttribute(positionAttribute, i);

                        // Calculate height based on the vertex's position on the XY plane
                        const height = getTerrainHeight(vertex.x, vertex.y); // Use helper function (uses vertex.y before rotation)

                        // Apply this calculated height to the Z coordinate of the vertex buffer
                        // This Z value will become the world Y height after rotation
                        positionAttribute.setZ(i, height); // Apply height to Z <-- SET Z, NOT Y

                    }
                    positionAttribute.needsUpdate = true; // Tell Three.js vertices have changed
                    groundGeometry.computeVertexNormals(); // Recalculate normals for correct lighting
                    console.log("Terrain geometry generated.");

                    // --- Create Ground Material ---
                    // Use wireframe for testing geometry, then switch back
                    // const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                    const groundMaterial = new THREE.MeshStandardMaterial({
                        map: texture, // Apply the loaded texture
                        color: 0x88aa66, // Slight green tint for grass
                        side: THREE.FrontSide, // Only need front side for performance
                        roughness: 1.0, // Maximum roughness for matte terrain
                        metalness: 0.0, // No metallic properties for grass
                        envMapIntensity: 0.3 // Subtle environment reflections
                    });

                    // --- Create Ground Mesh ---
                    const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                    // This rotation correctly turns the Z modifications into world Y height
                    groundMesh.rotation.x = -Math.PI / 2;
                    groundMesh.receiveShadow = true;
                    scene.add(groundMesh);
                    console.log("Ground mesh created and added to scene.");
                },
                // --- Progress Callback (Optional) ---
                undefined, // Not using progress here
                // --- Error Callback ---
                (error) => {
                    console.error('Failed to load ground texture:', error);
                    console.warn("Using procedural fallback ground texture.");

                    // Create a procedural grass texture using canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');

                    // Create grass-like pattern
                    for (let i = 0; i < canvas.width; i++) {
                        for (let j = 0; j < canvas.height; j++) {
                            const noise = Math.random() * 40 - 20;
                            const r = 85 + noise;
                            const g = 120 + noise;
                            const b = 70 + noise;
                            ctx.fillStyle = `rgb(${r},${g},${b})`;
                            ctx.fillRect(i, j, 1, 1);
                        }
                    }

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    const repeats = GROUND_SIZE / 100;
                    texture.repeat.set(repeats, repeats);

                    // Create terrain with same hills as success case
                    const groundGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE, GROUND_SEGMENTS, GROUND_SEGMENTS);
                    const positionAttribute = groundGeometry.attributes.position;
                    const vertex = new THREE.Vector3();

                    for (let i = 0; i < positionAttribute.count; i++) {
                        vertex.fromBufferAttribute(positionAttribute, i);
                        const height = getTerrainHeight(vertex.x, vertex.y);
                        positionAttribute.setZ(i, height);
                    }
                    positionAttribute.needsUpdate = true;
                    groundGeometry.computeVertexNormals();

                    const groundMaterial = new THREE.MeshStandardMaterial({
                        map: texture,
                        color: 0x88aa66,
                        side: THREE.FrontSide,
                        roughness: 1.0,
                        metalness: 0.0,
                        envMapIntensity: 0.3
                    });

                    const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                    groundMesh.rotation.x = -Math.PI / 2;
                    groundMesh.receiveShadow = true;
                    scene.add(groundMesh);
                }
            );
        }

        function getTerrainHeight(worldX, worldZ) {
            // Calculate height based on the same formula used in createGround
            // Remember: world Z maps to the original plane's Y coordinate before rotation
            const height = Math.sin(worldX * TERRAIN_FREQUENCY) *
                        Math.cos(worldZ * TERRAIN_FREQUENCY) * // Use world Z here
                        TERRAIN_AMPLITUDE;
            return height;
        }

        function createPlayerAircraft() {
            // Simple cone shape for the aircraft body
            // const geometry = new THREE.ConeGeometry(2, 8, 8); // Radius, Height, Segments
            // geometry.rotateX(Math.PI / 2); // Point forward along Z
            // const material = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x330000 });
            // playerAircraft = new THREE.Mesh(geometry, material);
            // playerAircraft.position.set(0, 50, 0); // Start above ground
            // playerAircraft.castShadow = true;
            
            if (!loadedModelTemplate) {
                console.warn("Cannot create player aircraft, model template not loaded.");
                return;
            }
            console.log("Creating player aircraft from template...");

            // --- Clone the loaded model ---
            playerAircraft = loadedModelTemplate.clone(); // Use THREE.SkeletonUtils.clone(loadedModelTemplate) if model is animated/skinned

            // --- Set Initial Position ---
            // Note: Scale and shadow settings are inherited from the template
            playerAircraft.position.set(0, 50, 0);
            
            // --- Add to Scene ---
            scene.add(playerAircraft);
            console.log("Player aircraft added to scene at", playerAircraft.position);

            // Initialize physics variables
            // Ensure these are created AFTER playerAircraft is assigned
            playerVelocity = new THREE.Vector3();
            playerAngularVelocity = new THREE.Vector3();

            // Attach camera to the player (adjust offset as needed)
            // camera.position.set(0, 3, -10); // Behind and slightly above
            // camera.position.set(0, 5, -20); // Further back (Z=-20) and slightly higher (Y=5)
            // playerAircraft.add(camera);
        }

        function createTrees(count) {
            console.log(`Creating ${count} trees...`);

            // --- Define Geometry & Material ONCE ---
            const trunkGeometry = new THREE.CylinderGeometry(TRUNK_RADIUS, TRUNK_RADIUS, TRUNK_HEIGHT, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 }); // Brown

            const foliageGeometry = new THREE.ConeGeometry(FOLIAGE_RADIUS, FOLIAGE_HEIGHT, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 }); // Forest Green

            // --- Create Instanced Meshes ---
            // Allocate space for 'count' instances
            const trunkInstancedMesh = new THREE.InstancedMesh(trunkGeometry, trunkMaterial, count);
            const foliageInstancedMesh = new THREE.InstancedMesh(foliageGeometry, foliageMaterial, count);

            trunkInstancedMesh.castShadow = true;
            trunkInstancedMesh.receiveShadow = true; // Trunks can receive shadows from foliage
            foliageInstancedMesh.castShadow = true;
            // foliageInstancedMesh.receiveShadow = false; // Foliage usually doesn't receive much shadow

            // --- Calculate and Set Instance Transforms ---
            const matrix = new THREE.Matrix4(); // Reusable matrix
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            let actualTreeCount = 0; // Count how many trees are actually placed

            for (let i = 0; i < count; i++) {
                // --- Position ---
                const x = (Math.random() - 0.5) * GROUND_SIZE * 0.95; // Keep slightly away from edges
                const z = (Math.random() - 0.5) * GROUND_SIZE * 0.95;
                const y = getTerrainHeight(x, z);

                // Simple check: avoid placing trees too low (e.g., underwater if amplitude is large)
                // or too high on steep peaks, or inside buildings
                const minTreeHeight = -10; // Adjust as needed
                const maxTreeHeight = TERRAIN_AMPLITUDE * 0.8; // Avoid highest peaks maybe?
                let buildingCollision = false;
                const treeBox = new THREE.Box3( // Approximate bounding box for the tree base
                    new THREE.Vector3(x - FOLIAGE_RADIUS, y, z - FOLIAGE_RADIUS),
                    new THREE.Vector3(x + FOLIAGE_RADIUS, y + TRUNK_HEIGHT + FOLIAGE_HEIGHT, z + FOLIAGE_RADIUS)
                );
                for(const buildingBox of buildingBoundingBoxes) {
                    if (treeBox.intersectsBox(buildingBox)) {
                        buildingCollision = true;
                        break;
                    }
                }

                if (y > minTreeHeight && y < maxTreeHeight && !buildingCollision) {
                    // --- Trunk Transform ---
                    position.set(x, y + TRUNK_HEIGHT / 2, z); // Position base of trunk at terrain height
                    quaternion.setFromEuler(new THREE.Euler(0, Math.random() * Math.PI * 2, 0)); // Random Y rotation
                    scale.setScalar(0.8 + Math.random() * 0.4); // Slight random scale

                    matrix.compose(position, quaternion, scale);
                    trunkInstancedMesh.setMatrixAt(actualTreeCount, matrix);

                    // --- Foliage Transform (adjust Y position) ---
                    position.set(x, y + TRUNK_HEIGHT + FOLIAGE_HEIGHT / 2 - 1, z); // Position foliage above trunk (slight overlap)
                    // Use same random rotation and scale as trunk
                    matrix.compose(position, quaternion, scale);
                    foliageInstancedMesh.setMatrixAt(actualTreeCount, matrix);

                    actualTreeCount++; // Increment count of successfully placed trees
                }
                // If tree position is invalid, simply skip this iteration (i)
            }

            // Important: Update the count for the InstancedMesh if some trees were skipped
            trunkInstancedMesh.count = actualTreeCount;
            foliageInstancedMesh.count = actualTreeCount;

            // --- Add to Scene ---
            scene.add(trunkInstancedMesh);
            scene.add(foliageInstancedMesh);
            console.log(`Successfully created ${actualTreeCount} trees.`);
        }

        function createClouds() {
            console.log("Creating clouds...");
            const textureLoader = new THREE.TextureLoader();

            textureLoader.load(
                CLOUD_TEXTURE_URL,
                // Success Callback (Texture Loaded)
                (cloudTexture) => {
                    console.log("Cloud texture loaded.");

                    const cloudGeometry = new THREE.BufferGeometry();
                    const positions = [];

                    // Create random positions for each cloud particle
                    for (let i = 0; i < CLOUD_COUNT; i++) {
                        const x = (Math.random() - 0.5) * CLOUD_AREA_XZ;
                        const y = Math.random() * (CLOUD_ALTITUDE_MAX - CLOUD_ALTITUDE_MIN) + CLOUD_ALTITUDE_MIN;
                        const z = (Math.random() - 0.5) * CLOUD_AREA_XZ;
                        positions.push(x, y, z);
                    }

                    cloudGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

                    const cloudMaterial = new THREE.PointsMaterial({
                        size: CLOUD_SIZE * 1.5, // Larger for more volumetric feel
                        map: cloudTexture,
                        blending: THREE.NormalBlending, // More realistic blending
                        depthWrite: false,
                        transparent: true,
                        opacity: 0.8, // More opaque for better visibility
                        sizeAttenuation: true,
                        color: 0xffffff, // Pure white for realistic clouds
                        fog: true // React to scene fog for depth
                    });

                    clouds = new THREE.Points(cloudGeometry, cloudMaterial); // Assign to global variable
                    scene.add(clouds);
                    console.log("Clouds created and added to scene.");

                },
                // Progress (Optional)
                undefined,
                // Error Callback
                (error) => {
                    console.error("Failed to load cloud texture:", error);
                }
            );
        }

        function createJetTrailParticles() {
            console.log("Creating jet trail particle system...");

            // Create a pool of reusable particles for the jet trail
            const particleCount = 300;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const lifetimes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;

                // Orange/red hot exhaust colors
                colors[i * 3] = 1.0;     // R
                colors[i * 3 + 1] = 0.5; // G
                colors[i * 3 + 2] = 0.2; // B

                sizes[i] = 0;
                lifetimes[i] = 0;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const particleMaterial = new THREE.PointsMaterial({
                size: 15,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);

            // Store particle system info for animation
            jetTrailParticles = {
                system: particleSystem,
                positions: positions,
                colors: colors,
                sizes: sizes,
                lifetimes: lifetimes,
                particleCount: particleCount,
                currentParticle: 0,
                maxLifetime: 1.5 // seconds
            };

            console.log("Jet trail particle system created.");
        }

        function updateJetTrailParticles(deltaTime) {
            if (!jetTrailParticles || !playerAircraft) return;

            const { positions, colors, sizes, lifetimes, particleCount, maxLifetime } = jetTrailParticles;
            const positionAttribute = jetTrailParticles.system.geometry.attributes.position;
            const sizeAttribute = jetTrailParticles.system.geometry.attributes.size;
            const colorAttribute = jetTrailParticles.system.geometry.attributes.color;

            // OPTIMIZED: Track active particles and only update those
            let activeCount = 0;

            // Update existing particles - only process active ones
            for (let i = 0; i < particleCount; i++) {
                if (lifetimes[i] > 0) {
                    activeCount++;
                    lifetimes[i] -= deltaTime;

                    // Fade out and expand particles as they age
                    const lifeRatio = Math.max(0, lifetimes[i] / maxLifetime);
                    sizes[i] = 15 * (1 - lifeRatio) * 2;

                    // OPTIMIZED: Simplified color calculation
                    const rg = lifeRatio;
                    colors[i * 3] = rg;           // R
                    colors[i * 3 + 1] = rg * 0.5; // G
                    colors[i * 3 + 2] = rg * 0.2; // B

                    if (lifetimes[i] <= 0) {
                        sizes[i] = 0;
                    }
                }
            }

            // Emit new particles when boosting or flying
            if (controls.boost || playerVelocity.length() > 50) {
                const emitRate = controls.boost ? 10 : 5; // Particles per frame

                for (let e = 0; e < emitRate; e++) {
                    const idx = jetTrailParticles.currentParticle;

                    // Get exhaust position (behind the aircraft)
                    const exhaustOffset = new THREE.Vector3(0, 0, -40); // Behind aircraft
                    exhaustOffset.applyQuaternion(playerAircraft.quaternion);
                    const exhaustPos = playerAircraft.position.clone().add(exhaustOffset);

                    // Add some random spread
                    exhaustPos.x += (Math.random() - 0.5) * 5;
                    exhaustPos.y += (Math.random() - 0.5) * 5;
                    exhaustPos.z += (Math.random() - 0.5) * 5;

                    positions[idx * 3] = exhaustPos.x;
                    positions[idx * 3 + 1] = exhaustPos.y;
                    positions[idx * 3 + 2] = exhaustPos.z;

                    lifetimes[idx] = maxLifetime;
                    sizes[idx] = controls.boost ? 20 : 10;

                    // Bright orange for boost, dimmer for normal
                    colors[idx * 3] = controls.boost ? 1.0 : 0.8;
                    colors[idx * 3 + 1] = controls.boost ? 0.6 : 0.4;
                    colors[idx * 3 + 2] = controls.boost ? 0.3 : 0.1;

                    jetTrailParticles.currentParticle = (idx + 1) % particleCount;
                }
            }

            // OPTIMIZED: Only update buffers if there are active particles or new emissions
            if (activeCount > 0 || (controls.boost || playerVelocity.length() > 50)) {
                positionAttribute.needsUpdate = true;
                sizeAttribute.needsUpdate = true;
                colorAttribute.needsUpdate = true;
            }
        }

        function createCheckpoints() {
            console.log("Creating checkpoint rings...");
            const CHECKPOINT_COUNT = 10;
            const RING_RADIUS = 50;
            const RING_TUBE_RADIUS = 3;

            // Create ring geometry (torus)
            const ringGeometry = new THREE.TorusGeometry(RING_RADIUS, RING_TUBE_RADIUS, 16, 100);

            for (let i = 0; i < CHECKPOINT_COUNT; i++) {
                // Create glowing material for each ring
                const isNextCheckpoint = i === 0;
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: isNextCheckpoint ? 0x00ff00 : 0x0088ff,
                    emissive: isNextCheckpoint ? 0x00ff00 : 0x0088ff,
                    emissiveIntensity: isNextCheckpoint ? 1.0 : 0.5,
                    roughness: 0.3,
                    metalness: 0.7,
                    transparent: true,
                    opacity: 0.8
                });

                const ring = new THREE.Mesh(ringGeometry, ringMaterial);

                // Position checkpoints in a course around the map
                const angle = (i / CHECKPOINT_COUNT) * Math.PI * 2;
                const radius = GROUND_SIZE * 0.35;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = getTerrainHeight(x, z) + 80 + (i % 3) * 30; // Vary height

                ring.position.set(x, y, z);

                // Rotate ring to face the next checkpoint
                const nextAngle = ((i + 1) / CHECKPOINT_COUNT) * Math.PI * 2;
                const lookAtAngle = nextAngle - angle;
                ring.rotation.y = lookAtAngle;

                scene.add(ring);

                checkpoints.push({
                    mesh: ring,
                    position: new THREE.Vector3(x, y, z),
                    passed: false,
                    index: i
                });
            }

            console.log(`Created ${CHECKPOINT_COUNT} checkpoint rings.`);
        }

        function createPowerups() {
            console.log("Creating power-ups...");
            const POWERUP_COUNT = 15;

            for (let i = 0; i < POWERUP_COUNT; i++) {
                // Alternate between speed boost and shield
                const type = i % 2 === 0 ? 'speed' : 'shield';

                // Create powerup geometry (rotating cube or sphere)
                const geometry = type === 'speed' ?
                    new THREE.OctahedronGeometry(8, 0) :
                    new THREE.IcosahedronGeometry(8, 0);

                const material = new THREE.MeshStandardMaterial({
                    color: type === 'speed' ? 0xffaa00 : 0x00aaff,
                    emissive: type === 'speed' ? 0xffaa00 : 0x00aaff,
                    emissiveIntensity: 1.5,
                    metalness: 0.8,
                    roughness: 0.2
                });

                const powerup = new THREE.Mesh(geometry, material);

                // Random position on terrain
                const x = (Math.random() - 0.5) * GROUND_SIZE * 0.8;
                const z = (Math.random() - 0.5) * GROUND_SIZE * 0.8;
                const y = getTerrainHeight(x, z) + 15;

                powerup.position.set(x, y, z);
                scene.add(powerup);

                powerups.push({
                    mesh: powerup,
                    type: type,
                    position: new THREE.Vector3(x, y, z),
                    active: true,
                    rotationSpeed: 0.02
                });
            }

            console.log(`Created ${POWERUP_COUNT} power-ups.`);
        }

        function setupRaceControls() {
            const startBtn = document.getElementById('start-race-btn');
            if (startBtn) {
                startBtn.addEventListener('click', startRace);
            }

            // Update best time display
            if (bestTime) {
                const bestTimeDisplay = document.getElementById('best-time-display');
                if (bestTimeDisplay) {
                    bestTimeDisplay.textContent = `BEST: ${parseFloat(bestTime).toFixed(2)}s`;
                }
            }
        }

        function startRace() {
            console.log("Starting race!");
            isRacing = true;
            currentCheckpoint = 0;
            checkpointsPassed = 0;
            raceStartTime = Date.now();

            // Reset all checkpoints
            checkpoints.forEach((cp, index) => {
                cp.passed = false;
                cp.mesh.material.color.setHex(index === 0 ? 0x00ff00 : 0x0088ff);
                cp.mesh.material.emissive.setHex(index === 0 ? 0x00ff00 : 0x0088ff);
                cp.mesh.material.emissiveIntensity = index === 0 ? 1.0 : 0.5;
            });

            // Show race info, hide start button
            document.getElementById('race-info').style.display = 'block';
            document.getElementById('race-controls').style.display = 'none';

            // Update checkpoint progress
            updateCheckpointUI();
        }

        function updateCheckpointUI() {
            const progressElem = document.getElementById('checkpoint-progress');
            if (progressElem) {
                progressElem.textContent = `${checkpointsPassed}/${checkpoints.length}`;
            }
        }

        function checkCheckpointCollision() {
            if (!isRacing || !playerAircraft) return;

            const currentCp = checkpoints[currentCheckpoint];
            if (!currentCp || currentCp.passed) return;

            // Check if player is passing through the ring
            const distance = playerAircraft.position.distanceTo(currentCp.position);
            const RING_RADIUS = 50;

            if (distance < RING_RADIUS + 20) { // Add buffer for easier passing
                // Check if we're roughly in the plane of the ring
                const relativePos = playerAircraft.position.clone().sub(currentCp.position);
                const ringNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(currentCp.mesh.quaternion);
                const dotProduct = Math.abs(relativePos.dot(ringNormal));

                if (dotProduct < 30) { // Within plane threshold
                    passCheckpoint(currentCp);
                }
            }
        }

        function passCheckpoint(checkpoint) {
            checkpoint.passed = true;
            checkpointsPassed++;
            currentCheckpoint++;

            // Visual feedback
            checkpoint.mesh.material.color.setHex(0x00ff00);
            checkpoint.mesh.material.emissiveIntensity = 2.0;

            // Show notification
            const notification = document.getElementById('checkpoint-notification');
            if (notification) {
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 500);
            }

            // Update next checkpoint appearance
            if (currentCheckpoint < checkpoints.length) {
                const nextCp = checkpoints[currentCheckpoint];
                nextCp.mesh.material.color.setHex(0x00ff00);
                nextCp.mesh.material.emissive.setHex(0x00ff00);
                nextCp.mesh.material.emissiveIntensity = 1.0;
            }

            updateCheckpointUI();

            // Check if race finished
            if (checkpointsPassed >= checkpoints.length) {
                finishRace();
            }
        }

        function finishRace() {
            isRacing = false;
            const finalTime = raceTime;

            console.log(`Race finished! Time: ${finalTime.toFixed(2)}s`);

            // Check and save best time
            if (!bestTime || finalTime < parseFloat(bestTime)) {
                bestTime = finalTime.toFixed(2);
                localStorage.setItem('vibejet_best_time', bestTime);

                // Show new record notification
                alert(`🏆 NEW RECORD! ${finalTime.toFixed(2)}s`);
            } else {
                alert(`Race complete! Time: ${finalTime.toFixed(2)}s\nBest: ${bestTime}s`);
            }

            // Show start button again
            document.getElementById('race-controls').style.display = 'block';
            document.getElementById('race-info').style.display = 'none';

            // Update best time display
            const bestTimeDisplay = document.getElementById('best-time-display');
            if (bestTimeDisplay) {
                bestTimeDisplay.textContent = `BEST: ${bestTime}s`;
            }
        }

        function updatePowerups(deltaTime) {
            powerups.forEach((powerup) => {
                if (!powerup.active) return;

                // Rotate powerup
                powerup.mesh.rotation.x += powerup.rotationSpeed;
                powerup.mesh.rotation.y += powerup.rotationSpeed * 1.5;

                // Bob up and down
                powerup.mesh.position.y = powerup.position.y + Math.sin(Date.now() * 0.002) * 5;

                // Check collision with player
                if (playerAircraft) {
                    const distance = playerAircraft.position.distanceTo(powerup.position);
                    if (distance < 20) {
                        collectPowerup(powerup);
                    }
                }
            });

            // Update shield
            if (playerShield && Date.now() > shieldEndTime) {
                playerShield = false;
                console.log("Shield expired");
            }
        }

        function collectPowerup(powerup) {
            powerup.active = false;
            powerup.mesh.visible = false;

            if (powerup.type === 'speed') {
                // Speed boost for 3 seconds
                const boostMultiplier = 1.5;
                const originalSpeed = PLAYER_SPEED;
                // Would need to modify PLAYER_SPEED temporarily
                console.log("Speed boost activated!");

                // Respawn after 30 seconds
                setTimeout(() => {
                    powerup.active = true;
                    powerup.mesh.visible = true;
                }, 30000);

            } else if (powerup.type === 'shield') {
                // Shield for 10 seconds
                playerShield = true;
                shieldEndTime = Date.now() + 10000;
                console.log("Shield activated!");

                // Respawn after 30 seconds
                setTimeout(() => {
                    powerup.active = true;
                    powerup.mesh.visible = true;
                }, 30000);
            }
        }

        function updateRaceTimer() {
            if (!isRacing) return;

            raceTime = (Date.now() - raceStartTime) / 1000; // Convert to seconds

            const raceTimeElem = document.getElementById('race-time');
            if (raceTimeElem) {
                raceTimeElem.textContent = raceTime.toFixed(2);
            }
        }

        function createRoads() {
            if (!roadTexture) {
                console.warn("Road texture not loaded, skipping road creation.");
                return;
            }
            console.log(`Creating ${ROAD_COUNT} road segments...`);

            const roadMaterial = new THREE.MeshStandardMaterial({
                map: roadTexture,
                side: THREE.FrontSide, // Only need to see the top
                roughness: 0.9,
                metalness: 0.0,
                polygonOffset: true, // Help prevent z-fighting with ground
                polygonOffsetFactor: -1.0,
                polygonOffsetUnits: -1.0
            });

            for (let i = 0; i < ROAD_COUNT; i++) {
                // --- Generate Path ---
                const x1 = (Math.random() - 0.5) * GROUND_SIZE;
                const z1 = (Math.random() - 0.5) * GROUND_SIZE;
                const angle = Math.random() * Math.PI * 2;
                const length = ROAD_MIN_LENGTH + Math.random() * (ROAD_MAX_LENGTH - ROAD_MIN_LENGTH);
                const x2 = x1 + Math.sin(angle) * length; // Use sin for X based on angle
                const z2 = z1 + Math.cos(angle) * length; // Use cos for Z based on angle

                // Clamp end points to stay roughly within bounds
                const x2c = Math.max(-GROUND_SIZE/2, Math.min(GROUND_SIZE/2, x2));
                const z2c = Math.max(-GROUND_SIZE/2, Math.min(GROUND_SIZE/2, z2));

                const dx = x2c - x1;
                const dz = z2c - z1;
                const pathLength = Math.sqrt(dx*dx + dz*dz);

                if (pathLength < ROAD_MIN_LENGTH) continue; // Skip if clamped path is too short

                // --- Create & Deform Geometry ---
                const lengthSegments = Math.max(1, Math.ceil(pathLength / ROAD_SEGMENT_LENGTH));
                // Create plane geometry ALONG Y axis initially (width=X, length=Y)
                const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, pathLength, 1, lengthSegments);
                const positionAttribute = roadGeometry.attributes.position;
                const tempVertex = new THREE.Vector3(); // To read original vertex positions

                for (let j = 0; j < positionAttribute.count; j++) {
                    tempVertex.fromBufferAttribute(positionAttribute, j); // Read local vertex (x, y, z=0)

                    // 't' is the fraction along the road's length (mapping local Y to 0-1 range)
                    const t = (tempVertex.y + pathLength / 2) / pathLength;
                    // 'w' is the fraction across the road's width (mapping local X to -0.5 to 0.5 range)
                    const w = tempVertex.x / ROAD_WIDTH;

                    // Calculate the world XZ position for this vertex
                    const worldX = x1 + dx * t;
                    const worldZ = z1 + dz * t;

                    // Calculate terrain height at this world position
                    const terrainY = getTerrainHeight(worldX, worldZ);
                    const roadY = terrainY + ROAD_THICKNESS_OFFSET; // Place slightly above terrain

                    // Calculate world position offset based on road width and path direction perp.
                    // Normal vector to path (dz, -dx), normalized
                    const nx = dz / pathLength;
                    const nz = -dx / pathLength;
                    const offsetX = nx * w * ROAD_WIDTH;
                    const offsetZ = nz * w * ROAD_WIDTH;

                    // Set the vertex position in WORLD coordinates into the buffer's Z value (before mesh rotation)
                    // This vertex's final world Y position
                    positionAttribute.setZ(j, roadY);
                    // Adjust the vertex's X and Y based on world pos + offset (mapping to unrotated plane's X/Y)
                    positionAttribute.setX(j, worldX + offsetX);
                    positionAttribute.setY(j, worldZ + offsetZ); // Store world Z in buffer Y before final mesh rotation
                }

                positionAttribute.needsUpdate = true;
                roadGeometry.computeVertexNormals(); // Normals for lighting on the road

                // --- Create Mesh ---
                // Clone material for unique texture repeats per road segment
                const materialInstance = roadMaterial.clone();
                materialInstance.map = roadTexture.clone(); // Clone texture for unique repeat settings
                materialInstance.map.needsUpdate = true;
                // Repeat texture along the length; adjust V repeat based on aspect ratio/desired look
                materialInstance.map.repeat.set(1, pathLength / ROAD_WIDTH);

                const roadMesh = new THREE.Mesh(roadGeometry, materialInstance);

                // --- Position & Orient Mesh ---
                // The geometry vertices are now essentially in world positions, but stored in X, Y, Z buffer
                // where Z holds the world Y height. We need to rotate the mesh to make Z become Y.
                roadMesh.rotation.x = -Math.PI / 2;
                // Position mesh at origin as vertices are world-relative (post-rotation)
                roadMesh.position.set(0, 0, 0);

                roadMesh.receiveShadow = true; // Roads receive shadows
                scene.add(roadMesh);
            }
            console.log("Roads created.");
        }

        function setupControls() {
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'KeyW': case 'ArrowUp':    controls.forward = 1; break;
                    case 'KeyS': case 'ArrowDown':  controls.backward = 1; break; // Optional: Brake/Reverse?
                    case 'KeyA': case 'ArrowLeft':  controls.left = 1; break; // Yaw left
                    case 'KeyD': case 'ArrowRight': controls.right = 1; break; // Yaw right
                    case 'KeyQ':                    controls.rollLeft = 1; break; // Roll left
                    case 'KeyE':                    controls.rollRight = 1; break; // Roll right
                    case 'ShiftLeft': case 'ShiftRight': controls.boost = 1; break;
                    case 'ControlLeft': case 'ControlRight': controls.down = 1; break; // Pitch down
                    case 'Space':                   controls.up = 1; break;     // Pitch up
                }
            });

            document.addEventListener('keyup', (event) => {
                 switch(event.code) {
                    case 'KeyW': case 'ArrowUp':    controls.forward = 0; break;
                    case 'KeyS': case 'ArrowDown':  controls.backward = 0; break;
                    case 'KeyA': case 'ArrowLeft':  controls.left = 0; break;
                    case 'KeyD': case 'ArrowRight': controls.right = 0; break;
                    case 'KeyQ':                    controls.rollLeft = 0; break;
                    case 'KeyE':                    controls.rollRight = 0; break;
                    case 'ShiftLeft': case 'ShiftRight': controls.boost = 0; break;
                    case 'ControlLeft': case 'ControlRight': controls.down = 0; break;
                    case 'Space':                   controls.up = 0; break;
                }
            });
        }

        function setupWebSocket() {
            ws = new WebSocket(WEBSOCKET_URL);

            ws.onopen = () => {
                console.log('WebSocket connection established');
                // Maybe request initial game state or player ID here if needed
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    // console.log('Message from server:', message);

                    switch(message.type) {
                        case 'assign_id':
                            playerId = message.id;
                            console.log('Assigned player ID:', playerId);
                            break;
                        case 'player_update':
                            if (message.id !== playerId) { // Update other players
                                updateOtherPlayer(message.id, message.data);
                            }
                            break;
                        case 'player_updates_batch':
                            // OPTIMIZED: Handle bundled updates from server (50% less bandwidth!)
                            message.updates.forEach(update => {
                                updateOtherPlayer(update.id, update.data);
                            });
                            break;
                        case 'player_join':
                            if (message.id !== playerId) {
                                console.log('Player joined:', message.id);
                                addOtherPlayer(message.id, message.data);
                            }
                            break;
                        case 'player_leave':
                            if (otherPlayers.has(message.id)) {
                                console.log('Player left:', message.id);
                                removeOtherPlayer(message.id);
                            }
                            break;
                         case 'world_state': // Initial state for newly joined player
                            message.players.forEach(playerData => {
                                if (playerData.id !== playerId) {
                                    addOtherPlayer(playerData.id, playerData.data);
                                }
                            });
                            break;
                        default:
                            console.log('Unknown message type:', message.type);
                    }
                } catch (error) {
                    console.error('Failed to parse message or process:', error);
                }
                updatePlayerCount();
            };

            ws.onerror = (error) => {
                console.error('WebSocket Error:', error);
                displayError("Connection error. Please refresh.");
            };

            ws.onclose = () => {
                console.log('WebSocket connection closed');
                playerId = null;
                // Clear other players and their trail systems
                otherPlayers.forEach(player => {
                    scene.remove(player.mesh);
                    if (player.trailSystem) {
                        scene.remove(player.trailSystem);
                        player.trailSystem.geometry.dispose();
                        player.trailSystem.material.dispose();
                    }
                });
                otherPlayers.clear();
                updatePlayerCount();
                displayError("Disconnected. Please refresh.");
            };
        }

        function displayError(message) {
             const errorDiv = document.createElement('div');
             errorDiv.style.position = 'absolute';
             errorDiv.style.top = '50%';
             errorDiv.style.left = '50%';
             errorDiv.style.transform = 'translate(-50%, -50%)';
             errorDiv.style.color = 'red';
             errorDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
             errorDiv.style.padding = '20px';
             errorDiv.style.fontSize = '20px';
             errorDiv.style.fontFamily = 'monospace';
             errorDiv.textContent = message;
             document.body.appendChild(errorDiv);
        }

        function addOtherPlayer(id, data) {
            // Don't add if player already exists or the model template isn't loaded yet
            if (otherPlayers.has(id) || !loadedModelTemplate) {
                // console.log(`Skipping addOtherPlayer for ${id}: Already exists or template not ready.`);
                return;
            }

            console.log(`Adding other player ${id} from template...`);
            const otherAircraftMesh = loadedModelTemplate.clone(); // Use THREE.SkeletonUtils.clone if needed

            // Use the same geometry/material for now, maybe different color later
            // const geometry = new THREE.ConeGeometry(2, 8, 8);
            // geometry.rotateX(Math.PI / 2);
            // const material = new THREE.MeshStandardMaterial({ color: 0x0000ff }); // Blue for others
            // const otherAircraft = new THREE.Mesh(geometry, material);
            // otherAircraft.castShadow = true; // Other players cast shadows too

            // Optional: Apply a visual tint or variation later if desired
            // 
            // Apply a visual difference (e.g., slight color tint) - This is complex
            // and depends heavily on the model's material structure.
            // Simple attempt: If materials are standard, try tinting.
            otherAircraftMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) { // Handle multi-materials
                        child.material.forEach(mat => {
                            if (mat.isMeshStandardMaterial) {
                                // Create a unique material instance to avoid changing the template/other clones
                                // Note: Cloning materials can be resource intensive
                                // child.material = mat.clone();
                                // child.material.color.multiplyScalar(0.7); // Example: Make it darker
                                // A simpler tint might just modify emissive or add a colored light later
                            }
                        });
                    } else if (child.material.isMeshStandardMaterial) {
                        // child.material = child.material.clone();
                        // child.material.color.multiplyScalar(0.7);
                    }
                }
            });
            // For now, let's skip complex material cloning/tinting and they'll look the same.
        
            // Set initial position and rotation from network data if provided
            const targetPosition = new THREE.Vector3();
            const targetQuaternion = new THREE.Quaternion();

            if (data && data.position && data.quaternion) {
                try {
                    otherAircraftMesh.position.fromArray(data.position);
                    otherAircraftMesh.quaternion.fromArray(data.quaternion);
                    targetPosition.fromArray(data.position);
                    targetQuaternion.fromArray(data.quaternion);
                } catch (e) {
                    console.error(`Error setting position/quaternion for player ${id}:`, e, data);
                }
            } else {
                // Place at default spawn or origin if no data provided? Or hide until first update?
                // For now, it will appear at (0,0,0) by default if no data.
            }

            // Create dedicated trail system for this player
            const trailSystem = createMiniTrailSystem();
            scene.add(trailSystem);

            // Add the mesh to the scene
            scene.add(otherAircraftMesh);
            otherPlayers.set(id, {
                mesh: otherAircraftMesh,
                lastUpdate: Date.now(),
                targetPosition: targetPosition,
                targetQuaternion: targetQuaternion,
                trailSystem: trailSystem,
                trailParticleIndex: 0
            });

            console.log(`Added player ${id} to scene with trail system.`);
            updatePlayerCount(); // Update the player count display
        }

        function createMiniTrailSystem() {
            // Create a smaller trail system for other players (50 particles instead of 300)
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            // Initialize all particles at origin with zero size
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;

                // Blue-ish trail for other players
                colors[i * 3] = 0.3;
                colors[i * 3 + 1] = 0.6;
                colors[i * 3 + 2] = 1.0;

                sizes[i] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 10,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.6
            });

            return new THREE.Points(geometry, material);
        }

        function updateOtherPlayer(id, data) {
            const player = otherPlayers.get(id);
            if (player) {
                // OPTIMIZED: Store target position/rotation for smooth interpolation
                if (!player.targetPosition) {
                    player.targetPosition = new THREE.Vector3();
                    player.targetQuaternion = new THREE.Quaternion();
                }

                player.targetPosition.fromArray(data.position);
                player.targetQuaternion.fromArray(data.quaternion);
                player.lastUpdate = Date.now();
            } else {
                // If we receive an update for a player we don't know, add them
                addOtherPlayer(id, data);
            }
        }

        function interpolateOtherPlayers(deltaTime) {
            const interpolationSpeed = 10.0; // Adjust for smoothness (higher = snappier)

            otherPlayers.forEach((player) => {
                if (player.targetPosition && player.targetQuaternion) {
                    // Smooth position interpolation
                    player.mesh.position.lerp(player.targetPosition, deltaTime * interpolationSpeed);

                    // Smooth rotation interpolation (slerp for quaternions)
                    player.mesh.quaternion.slerp(player.targetQuaternion, deltaTime * interpolationSpeed);
                }
            });
        }

        function updateOtherPlayerTrails(deltaTime) {
            otherPlayers.forEach((player, id) => {
                if (player.trailSystem && player.mesh) {
                    const positions = player.trailSystem.geometry.attributes.position.array;
                    const colors = player.trailSystem.geometry.attributes.color.array;
                    const sizes = player.trailSystem.geometry.attributes.size.array;
                    const particleCount = 50;

                    // Shift all particles back in the array (circular buffer approach)
                    for (let i = particleCount - 1; i > 0; i--) {
                        // Copy position from previous particle
                        positions[i * 3] = positions[(i - 1) * 3];
                        positions[i * 3 + 1] = positions[(i - 1) * 3 + 1];
                        positions[i * 3 + 2] = positions[(i - 1) * 3 + 2];

                        // Fade out older particles
                        colors[i * 3] = colors[(i - 1) * 3] * 0.95;
                        colors[i * 3 + 1] = colors[(i - 1) * 3 + 1] * 0.95;
                        colors[i * 3 + 2] = colors[(i - 1) * 3 + 2] * 0.95;

                        sizes[i] = sizes[i - 1] * 0.98;
                    }

                    // Add new particle at exhaust position
                    const exhaustOffset = new THREE.Vector3(0, 0, -40);
                    exhaustOffset.applyQuaternion(player.mesh.quaternion);
                    const exhaustPos = player.mesh.position.clone().add(exhaustOffset);

                    positions[0] = exhaustPos.x;
                    positions[1] = exhaustPos.y;
                    positions[2] = exhaustPos.z;

                    // Blue trail color for other players
                    colors[0] = 0.3;
                    colors[1] = 0.6;
                    colors[2] = 1.0;

                    sizes[0] = 15;

                    // Mark for update
                    player.trailSystem.geometry.attributes.position.needsUpdate = true;
                    player.trailSystem.geometry.attributes.color.needsUpdate = true;
                    player.trailSystem.geometry.attributes.size.needsUpdate = true;
                }
            });
        }

        function removeOtherPlayer(id) {
            const player = otherPlayers.get(id);
            if (player) {
                scene.remove(player.mesh);

                // Clean up trail system
                if (player.trailSystem) {
                    scene.remove(player.trailSystem);
                    player.trailSystem.geometry.dispose();
                    player.trailSystem.material.dispose();
                }

                otherPlayers.delete(id);
                console.log(`Removed player ${id} from scene.`);
                updatePlayerCount();
            }
        }

        // --- Game Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Get delta time with capping to prevent physics explosions on lag/tab switches
            let deltaTime = clock.getDelta();
            const MAX_DELTA = 0.1; // Cap at 100ms (10 FPS minimum)
            deltaTime = Math.min(deltaTime, MAX_DELTA);

            // --- Cloud Animation ---
            // update cloud object position slightly each frame to simulate drifting.
            if (clouds) {
                // Simple drift along X axis
                clouds.position.x += CLOUD_DRIFT_SPEED * deltaTime;
                // Optional: Wrap clouds around if they go too far
                if (clouds.position.x > CLOUD_AREA_XZ / 2) {
                    clouds.position.x -= CLOUD_AREA_XZ;
                }
            }

            updatePlayerMovement(deltaTime);
            updateCameraFOV();
            updateSpeedLines(); // Update speed lines effect
            updateDayNightCycle(deltaTime);
            updateJetTrailParticles(deltaTime);
            updateOtherPlayerTrails(deltaTime); // Update trails for other players
            checkCollisions();
            checkCheckpointCollision(); // Check checkpoint passing
            updatePowerups(deltaTime); // Animate and check powerup collection
            updateRaceTimer(); // Update race timer display
            interpolateOtherPlayers(deltaTime); // Smooth multiplayer movement

            // Send player state periodically
            const now = Date.now();
            if (ws && ws.readyState === WebSocket.OPEN && playerId && now - lastUpdateTime > UPDATE_INTERVAL_MS) {
                sendPlayerUpdate();
                lastUpdateTime = now;
            }

            // --- Camera Shake Update ---
            updateCameraShake(deltaTime);

            // --- Manual Camera Following Logic ---
            if (playerAircraft) {
                // Define camera offset relative to the aircraft (behind, above)
                // Reversed Z direction to match our updated forward vector
                const relativeCameraOffset = new THREE.Vector3(0, 2, 10); // Positive Z now to stay behind the aircraft

                // Calculate the desired world position of the camera
                const cameraOffset = relativeCameraOffset.applyQuaternion(playerAircraft.quaternion);
                const desiredCameraPosition = playerAircraft.position.clone().add(cameraOffset).add(cameraShake);

                // Smoothly move the camera to the desired position (lerp)
                // Use 0.1 for smoothing, or 1.0 to snap instantly for testing
                camera.position.lerp(desiredCameraPosition, 0.1);

                // Make the camera look at a point slightly above the aircraft's center
                const lookAtTarget = playerAircraft.position.clone().add(new THREE.Vector3(0, 1, 0)); // Look slightly above the origin
                camera.lookAt(lookAtTarget);
            }

            // Use composer for post-processing instead of direct render
            composer.render();
            updateInfoPanel();
        }

        function updatePlayerMovement(deltaTime) {
            if (!playerAircraft) return;

            const currentSpeed = playerVelocity.length();
            const maxSpeed = PLAYER_SPEED * (controls.boost ? AFTERBURNER_MULTIPLIER : 1.0);

            // --- Calculate Forces/Torques ---
            let thrust = controls.forward ? PLAYER_SPEED * 5.0 : 0; // Acceleration force
            thrust = thrust * (controls.boost ? AFTERBURNER_MULTIPLIER : 1.0);
            // Optional: Add braking force if controls.backward is used
            // if (controls.backward) thrust = -PLAYER_SPEED * 2.0;

            let targetPitch = 0;
            if (controls.up) targetPitch = PITCH_SPEED;
            if (controls.down) targetPitch = -PITCH_SPEED;

            let targetYaw = 0;
            if (controls.left) targetYaw = YAW_SPEED;
            if (controls.right) targetYaw = -YAW_SPEED;

            let targetRoll = 0;
            if (controls.rollLeft) targetRoll = ROLL_SPEED;
            if (controls.rollRight) targetRoll = -ROLL_SPEED;

            // --- Apply Angular Velocity ---
            // Simple angular acceleration based on input
            playerAngularVelocity.x += (targetPitch - playerAngularVelocity.x) * deltaTime * 5.0; // Pitch
            playerAngularVelocity.y += (targetYaw - playerAngularVelocity.y) * deltaTime * 5.0;   // Yaw
            playerAngularVelocity.z += (targetRoll - playerAngularVelocity.z) * deltaTime * 5.0; // Roll

            // Apply damping to angular velocity
            playerAngularVelocity.multiplyScalar(DAMPING);

            // --- Apply Rotation ---
            const deltaRotation = playerAngularVelocity.clone().multiplyScalar(deltaTime);
            const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaRotation.x);
            const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaRotation.y);
            const qz = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), deltaRotation.z);

            // Apply rotations in aircraft's local frame
            // OPTIMIZED: Three.js auto-normalizes on multiply, so no need to normalize every frame
            playerAircraft.quaternion.multiply(qx).multiply(qy).multiply(qz);

            // Normalize only occasionally to prevent accumulation errors (performance optimization)
            frameCount++;
            if (frameCount % 100 === 0) {
                playerAircraft.quaternion.normalize();
            }


            // --- Apply Linear Velocity ---
            // Original: Forward is defined as +Z in model space
            // const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(playerAircraft.quaternion);
            
            // Modified approach: Try using -Z as forward direction
            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(playerAircraft.quaternion);
            
            // Using the original approach with model rotations applied earlier
            // const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(playerAircraft.quaternion);
            const acceleration = forwardVector.multiplyScalar(thrust * deltaTime);

            playerVelocity.add(acceleration);

            // Apply damping/drag
            const dragFactor = 1.0 - (0.5 * deltaTime); // Simple linear drag
            playerVelocity.multiplyScalar(dragFactor);

            // Clamp speed
            if (playerVelocity.lengthSq() > maxSpeed * maxSpeed) {
                playerVelocity.normalize().multiplyScalar(maxSpeed);
            }

             // Minimum speed to prevent floating still
            const MIN_SPEED = 5.0;
            if (currentSpeed < MIN_SPEED && thrust === 0) {
                 playerVelocity.multiplyScalar(0.9); // Slow down faster when idle and slow
                 if (currentSpeed < 0.1) playerVelocity.set(0,0,0);
            }


            // --- Update Position ---
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerAircraft.position.add(deltaPosition);

            // --- Accurate Ground Collision using Terrain Height ---
            // FIXED: Now uses actual terrain height instead of approximate ground level
            const terrainHeight = getTerrainHeight(
                playerAircraft.position.x,
                playerAircraft.position.z
            );
            const aircraftRadius = 3.0; // Collision buffer for aircraft size

            if (playerAircraft.position.y < terrainHeight + aircraftRadius) {
                playerAircraft.position.y = terrainHeight + aircraftRadius;

                // Bounce effect based on downward velocity
                if (playerVelocity.y < 0) {
                    const impactSpeed = Math.abs(playerVelocity.y);

                    // Trigger screen shake on hard landing
                    if (impactSpeed > 20) {
                        shakeIntensity = Math.min(impactSpeed * 0.1, 5.0);
                    }

                    playerVelocity.y = Math.abs(playerVelocity.y) * 0.3; // Bounce up
                    playerVelocity.x *= 0.7; // Lose horizontal speed on impact
                    playerVelocity.z *= 0.7;
                }
            }
        }

        function updateCameraFOV() {
            const speedRatio = playerVelocity.length() / (PLAYER_SPEED * AFTERBURNER_MULTIPLIER);
            const targetFOV = CAMERA_BASE_FOV + speedRatio * CAMERA_MAX_FOV_BOOST;
            // Smooth FOV change
            camera.fov += (targetFOV - camera.fov) * 0.1;
            camera.updateProjectionMatrix();
        }

        function updateSpeedLines() {
            if (speedLinesPass) {
                // Calculate target intensity based on boost state
                const targetIntensity = controls.boost ? 1.0 : 0.0;
                const currentIntensity = speedLinesPass.uniforms.intensity.value;

                // Smooth transition to target intensity
                speedLinesPass.uniforms.intensity.value += (targetIntensity - currentIntensity) * 0.1;

                // Ensure boost indicator is visible when boosting
                const boostIndicator = document.getElementById('boost-indicator');
                if (boostIndicator) {
                    boostIndicator.style.display = controls.boost ? 'block' : 'none';
                }
            }
        }

        function updateCameraShake(deltaTime) {
            if (shakeIntensity > 0.1) {
                // Random shake direction
                cameraShake.set(
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity
                );

                // Decay shake over time
                shakeIntensity *= (1 - deltaTime * 8);
            } else {
                cameraShake.set(0, 0, 0);
                shakeIntensity = 0;
            }
        }

        function createCollisionParticles(position, velocity) {
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;

                // Random explosion direction
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 50,
                    (Math.random() - 0.5) * 100
                ));
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0xff6600,
                size: 5,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Animate and remove
            let lifetime = 1.0;
            const animateParticles = () => {
                lifetime -= 0.016;
                if (lifetime <= 0) {
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                    return;
                }

                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i].x * 0.016;
                    positions[i * 3 + 1] += velocities[i].y * 0.016;
                    positions[i * 3 + 2] += velocities[i].z * 0.016;

                    velocities[i].y -= 50 * 0.016; // Gravity
                }
                particles.geometry.attributes.position.needsUpdate = true;
                material.opacity = lifetime;

                requestAnimationFrame(animateParticles);
            };
            animateParticles();
        }

        function updateDayNightCycle(deltaTime) {
            const cycleSpeed = (2 * Math.PI) / (DAY_NIGHT_CYCLE_MINUTES * 60); // Radians per second
            sunAngle += cycleSpeed * deltaTime;
            sunAngle %= (2 * Math.PI); // Keep angle between 0 and 2PI

            const sunY = Math.sin(sunAngle);
            const sunX = Math.cos(sunAngle);

            sunLight.position.set(sunX * 1500, sunY * 1000, 1000); // Adjust Z for angled light
            sunLight.target.position.set(0, 0, 0); // Keep light focused on the center

            // Adjust light intensity and colors based on sun angle
            if (sunY > 0) { // Daytime
                const intensity = Math.max(0.1, sunY) * 1.5; // Brighter during day, min intensity
                sunLight.intensity = intensity;
                skyLight.intensity = Math.max(0.2, sunY * 0.6); // Ambient light stronger during day
                sunLight.color.setHSL(0.1, 1, Math.max(0.5, sunY)); // Yellowish sun
                skyLight.color.setHSL(0.6, 0.6, Math.max(0.3, sunY * 0.7)); // Bluish sky
                scene.fog.color.setHSL(0.6, 0.3, Math.max(0.6, sunY * 0.8)); // Lighter fog
                scene.fog.near = 1000 + (1-sunY) * 2000; // Fog denser near horizon at dawn/dusk
                scene.fog.far = 15000 - (1-sunY) * 5000;
                renderer.setClearColor(skyLight.color); // Match background to sky
            } else { // Nighttime
                sunLight.intensity = 0; // Sun off
                skyLight.intensity = 0.1 + Math.abs(sunY) * 0.1; // Dim ambient from moon/stars
                skyLight.color.setHSL(0.6, 0.3, 0.1); // Dark blue night sky
                scene.fog.color.setHSL(0.6, 0.1, 0.05); // Darker fog
                scene.fog.near = 500;
                scene.fog.far = 8000;
                 renderer.setClearColor(0x000011); // Dark night background
            }
             // Moon (could be another light source or just affect ambient)
             // For simplicity, we are just using the skyLight for night ambient
        }


        function checkCollisions() {
            // Guard against playerAircraft not being ready or not being a group with children yet
            if (!playerAircraft || !playerAircraft.isGroup || !playerAircraft.children || playerAircraft.children.length === 0) {
                return false; // Not ready to check collisions
            }

            // OPTIMIZED: Use sphere-based collision detection instead of expensive Box3.setFromObject
            // This is 10-30x faster than the previous method!
            isColliding = false; // Reset collision state
            const playerPos = playerAircraft.position;

            for (const buildingBox of buildingBoundingBoxes) {
                // Sphere-AABB collision test (much faster than Box3 traversal)
                const closestPoint = new THREE.Vector3(
                    Math.max(buildingBox.min.x, Math.min(playerPos.x, buildingBox.max.x)),
                    Math.max(buildingBox.min.y, Math.min(playerPos.y, buildingBox.max.y)),
                    Math.max(buildingBox.min.z, Math.min(playerPos.z, buildingBox.max.z))
                );

                const distanceSq = closestPoint.distanceToSquared(playerPos);

                if (distanceSq < playerCollisionRadius * playerCollisionRadius) {
                    // --- Collision Response ---
                    isColliding = true;

                    // Find collision normal
                    const buildingCenter = new THREE.Vector3();
                    buildingBox.getCenter(buildingCenter);
                    const collisionNormal = playerPos.clone().sub(buildingCenter).normalize();

                    // Trigger screen shake based on impact speed
                    const impactSpeed = playerVelocity.length();
                    shakeIntensity = Math.min(impactSpeed * 0.05, 5.0);

                    // Reflect velocity (basic bounce)
                    const speed = playerVelocity.length();
                    if (speed > 1.0) { // Only reflect if moving significantly
                        playerVelocity.reflect(collisionNormal).multiplyScalar(0.5); // Lose half speed on impact
                    } else {
                        playerVelocity.set(0,0,0); // Stop if moving slowly
                    }

                    // Push player out of the building to prevent sticking
                    const penetrationDepth = playerCollisionRadius - Math.sqrt(distanceSq);
                    const pushOut = collisionNormal.multiplyScalar(penetrationDepth + 1.0);
                    playerAircraft.position.add(pushOut);

                    // Collision particle burst effect
                    createCollisionParticles(playerPos.clone(), playerVelocity.clone());

                    // For this simple check, stop after first collision found in a frame
                    break;
                }
            }

            // Traverse the playerAircraft group to find meshes and modify their materials' emissive property
            playerAircraft.traverse((child) => {
                if (child.isMesh && child.material) {
                    // Handle both single material and array of materials
                    const materials = Array.isArray(child.material) ? child.material : [child.material];

                    materials.forEach(mat => {
                        // Check if the material type supports emissive (like Standard or Physical)
                        if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
                            // Set emissive color based on collision state
                            // Use a brighter red for collision, black (no emission) otherwise
                            // Note: This assumes the base color is handled by the model's texture/material.
                            // If the loaded model isn't red, this will just add/remove a red glow.
                            mat.emissive.setHex(isColliding ? 0xaa0000 : 0x000000);
                        }
                    });
                }
            });

            return isColliding;
        }


        function sendPlayerUpdate() {
            if (!playerAircraft || !playerId) return;

            const data = {
                position: playerAircraft.position.toArray(),
                quaternion: playerAircraft.quaternion.toArray(),
                // Optional: Send velocity, boost state etc. if needed server-side
                // velocity: playerVelocity.toArray(),
                // boosting: controls.boost === 1
            };

            const message = {
                type: 'player_update',
                id: playerId, // Send own ID
                data: data
            };

            try {
                ws.send(JSON.stringify(message));
            } catch (error) {
                 console.error("Failed to send update:", error);
            }
        }

        function updateInfoPanel() {
            const speedKmh = playerVelocity.length() * 3.6; // Example conversion factor
            const altitude = playerAircraft.position.y;
            document.getElementById('speed').textContent = speedKmh.toFixed(0);
            document.getElementById('altitude').textContent = altitude.toFixed(1);

            // Update speedbar
            const maxSpeed = PLAYER_SPEED * AFTERBURNER_MULTIPLIER * 3.6; // Max possible speed in km/h
            const speedPercent = Math.min((speedKmh / maxSpeed) * 100, 100);
            document.getElementById('speedbar-fill').style.height = speedPercent + '%';

            // Update boost indicator
            const boostIndicator = document.getElementById('boost-indicator');
            if (controls.boost) {
                boostIndicator.style.display = 'block';
            } else {
                boostIndicator.style.display = 'none';
            }

            // Player count updated in WebSocket handlers
        }

         function updatePlayerCount() {
            document.getElementById('players-count').textContent = otherPlayers.size + 1; // +1 for self
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            ssaoPass.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start the game ---
        init();

    </script>
</body>
</html>